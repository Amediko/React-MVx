{"pages":[{"title":"React-MVx","text":"React-MVx bridges the gap between React and traditional MVx architecture, combining the powerful OO state management and two-way data binding with all the benefits of the unidirectional data flow. Type-R for &quot;M&quot; and &quot;VM&quot; Does the same to your data as the React does to the DOM. Deeply observable changes Painless state synchronization State is JSON-serializable by default Declarative validation and run-time schema checks. Serializable id-references. 10 times faster than BackboneJS. React for &quot;V&quot; React. Improved. Say no to singletons. Same technique to manage all levels of application state Handle forms naturally: Two-way data binding Transparent validation Cuts your code size 2-5x compared to React\/Redux. Choose your &quot;C&quot; react-router No router Whatever-you-like router","tags":"","url":"index.html"},{"title":"Getting Started","text":"","tags":"","url":"Getting_Started.html"},{"title":"Data binding and forms","text":"Edit user form. Flat local state, form, simple data binding.","tags":"","url":"Guides\/Data_binding_and_forms.html"},{"title":"Input Validation","text":"Previous example + state validation.","tags":"","url":"Guides\/Input_Validation.html"},{"title":"Editable Lists","text":"Users list example. Collections, state synchronization. Edit Dialog pattern.","tags":"","url":"Guides\/Editable_Lists.html"},{"title":"Paging","text":"Page pattern on the example of users list.","tags":"","url":"Guides\/Paging.html"},{"title":"id-references and stores","text":"Users and roles with many-to-many relationship. Read-only roles in store.","tags":"","url":"Guides\/id-references_and_stores.html"},{"title":"Layered application state","text":"Demonstrate the three levels of the state. Users and Roles pages example. Read-only global store. Mutable page-level store. Local component state.","tags":"","url":"Guides\/Layered_application_state.html"},{"title":"Overview","text":"React-MVx is built around the idea of universal state management featuring the same technique to manage the local component state, application page state, and the global application state. Basic building blocks of the application architecture are: React-MVx Component (extended React.Component) for the view layer. Records and Collection (provided by Type-R data framework) for managing all kinds of an application state. Links for two-way data binding. Stores (which is the subclass of the Record and can be dynamically created) for resolving record's id-references. React-MVx Component uses the Record class to manage its local state. Record can consists of other records and collections, describing the data structure of arbitrary complexity. All records are serializable by default, has deeply observable changes, and supports the declarative validation. The behavior of record's attributes and component state\/props elements is controlled with declarative type annotations. React-MVx extends React namespace and should be used instead of react. All class Component definitions must be preceeded with the @define decorator. import React, { define } from 'react-mvx' @define class HelloApp extends React.Component { static state = { count : 0 }; render(){ const { state } = this; return ( &lt;h1 onClick={ () =&gt; state.count++ }&gt; Hi there! { state.count } &lt;\/h1&gt;; ); } }","tags":"","url":"API_Reference\/Overview.html"},{"title":"Overview","text":"React-MVx UI Component React-MVx extends React namespace and should be used instead of react. All class Component definitions must be preceeded with the @define decorator. import React, { define } from 'react-mvx' @define class Hello extends React.Component { render(){ return &lt;h1&gt;'Hi there!'&lt;\/h1&gt;; } } React-MVx is built around the idea of universal state management featuring the same technique to manage the local component state, application page state, and the global application state. Type annotations cheat sheet The majority of React-MVx features are controlled with declarative props, state, store, and context type annotations. Everything (state, store, props, and context) Type annotations below represents the run-time type assertions. Annotation Description Ctor element has specified type Ctor.isRequired element is required Ctor.has.check(...) custom validation check state, store, and props You can specify the default value for an attribute or prop, and reactions on its change. Annotation Description Ctor.value( defaultValue ) element has default value defaultValue element has default value Ctor.has.watcher(...) custom reaction on element's change Ctor.has.events(...) listen to custom events from the element Ctor.has.changeEvents(...) update on element's changes state and store You have an an attribute-level control of the serialization and ownership for the state, store, and records attributes. Annotation Description Record.shared attribute holds the reference to the record Collection.Refs collection of references to the records Record.from(...) reference to the record from the specified collection Collection.subsetOf(...) collection of references to the records from the specified collection Ctor.has.parse(...) custom parse hook Ctor.has.toJSON(...) custom serialization hook Ctor.has.get(...) attribute read hook Ctor.has.set(...) attribute write hook Ctor.has.metadata(...) attach custom metadata to the attribute","tags":"","url":"API_Reference\/Component\/Overview.html"},{"title":"props","text":"Component static props declaration replaces standard React's propTypes and defaultProps. static props = { name : propDef, ... } Declare component props. Declaration is an object import React, { define } from 'react-mvx' @define class PropsDemo extends React.Component { static props = { name : Declaration, ... } } static pureRender = true Prevents subsequent render calls in case if props were unchanged. It's known as &quot;pure render&quot; optimization. Inner changes of records and collections are detected and taken into account. Thus, it works properly with mutable records and collections. static props declaration is required for pureRender to work. Only declared props will be tracked and compared. Properties declarations propDef name : Constructor Checks if component prop is an instance of the Constructor and puts the warning to the console if the prop type is not compatible. propDef name : Constructor.isRequired Mark property as required. import React, { define } from 'react-mvx' @define class PropsDemo extends React.Component { static props = { \/\/ Simple form of annotation is just the constructor function designating the type. optionalArray: Array, optionalBool: Boolean, optionalFunc: Function, optionalNumber: Number, optionalObject: Object, optionalString: String, optionalSymbol: Symbol, \/\/ Anything that can be rendered: numbers, strings, elements or an array \/\/ (or fragment) containing these types. optionalNode: React.Node, \/\/ A React element. optionalElement: React.Element, \/\/ You can also declare that a prop is an instance of a class. optionalMessage: Message, \/\/ You can chain any of the above with `isRequired` to make sure a warning \/\/ is shown if the prop isn't provided. requiredFunction : Function.isRequired }; ... } propDef name : Constructor.value( defaultValue ) Assign default property value. propDef name : defaultValue Assign default property value. The the type will be inferred from the defaultValue. Any function in props annotation is treated as a constructor. Thus, Function.value( defaultValue ) must be used to specify the defaults for functions. import React, { define } from 'react-mvx' @define class PropsDemo extends React.Component { static props = { withDefault : String.value( 'defaultValue' ), anotherDefault : 'defaultValue' } } propDef name : Constructor.has.watcher( 'componentMethodName' ) propDef name : Constructor.has.watcher( function( newValue, name ){ ... } ) Watcher is the function which is called when the particular prop is assigned with new value. Watcher is called after componentWillMount, and may be called during componentWillReceiveProps if the property is changed. Watcher is executed in the context of the component. import React, { define } from 'react-mvx' @define class PropsDemo extends React.Component { static props = { first : String.has.watcher( 'onFirstChange' ), second : Number.has.watcher( second =&gt; console.log( 'Received new prop:', second ) ) } onFirstChange( newValue, name ){ console.log( 'First prop is about to change:', newValue ); } } propDef name : RecordOrCollection.has.changeEvents( true ) Observe internal changes of the record or collection and update the component in case of changes. propDef name : EventSource.has.changeEvents( 'event1 event2 ...' ) Update the component in case if property triggers any of the listed events. import React, { define } from 'react-mvx' import { Record } from 'react-mvx' @define class PropsDemo extends React.Component { static props = { \/\/ Render on every change trackInnerChanges : Record.has.changeEvents( true ), \/\/ Render when record is added to or removed from the collection anotherDefault : Collection.has.changeEvents( 'add remove' ) } } propDef name : EventSource.has.events({ event : handler, ... }) Subscribe for events from the component property. handler can either be the name of the component's method, or the function handling the event. Handler is executed in the context of the component.","tags":"","url":"API_Reference\/Component\/props.html"},{"title":"state","text":"Component's state is modeled as Type-R Record. Record is created before componentWillMount() and disposed after componentWillUnmount(). All changed inside of the state record are observed, and the component is updated in case of change. static state = RecordConstructor Define stateful component with the state Record declared externally. static state = { name : attrDef, ... } Implicitly define state Record with a given attributes declaration. All declarations working on props works for the state as well. Refer to the Record documentation for the attributes declaration syntax. component.state Holds an object of the Record subclass. Do not use component.setState(). Use direct assignments to modify the state: this.state.x = 5; Refer to the Record documentation for the complete list of methods. component.transaction( fun ) Group the sequence of state (and props) updates in the single transaction leading to single UI update. this.transaction( state =&gt; { state.a++; state.b++; this.props.collection.reset(); }); Read more about transactions in Record's manual.","tags":"","url":"API_Reference\/Component\/state.html"},{"title":"store","text":"Stores in Type-R are internally similar to the Record and used to resolve one-to-many and many-to-many relationships by id. Stores must not be used to store UI state; they are intended to hold the shared domain state which is cross-referenced by id. There may be multiple stores in Rect-MVx. There is the single default store (Store.global) which is used to cache the data that must be accessible across the pages. Specifying the store for the top-level component sets this store as the primary one for all the internal state of the current component subtree. static store = existingStore Expose the existingStore to the component subtree. Update component on store changes. static store = StoreConstructor Creates the local store on component's mount and dispose it when component is unmounted. Expose the store to the component subtree. Update component on store changes. static store = { attrName : attrDef, ... } Implicitly create the Store subclass from the given attribute spec. Accepts the same attrDef as the state and Record. component.store When the static store is defined, provide the access to the store in component. Store is not directly accessible to the subcomponents; you have to pass values down as props.","tags":"","url":"API_Reference\/Component\/store.html"},{"title":"context","text":"Static context and childContext declarations replaces React's standard contextTypes and childContextTypes. static context = { name : propDef, ... } Replacement for standard contextTypes. static childContext = { name : propDef, ... } Replacement for standard childContextTypes. getChildContext() function is required to create the context as in raw React. Context declarations Subset of static props declaration is supported for the context propDef. propDef name : Constructor Checks whenever the value is an instance of the Constructor and puts the warning to the console if the prop type is not compatible. propDef name : Constructor.isRequired Value is required.","tags":"","url":"API_Reference\/Component\/context.html"},{"title":"Other members","text":"Links to state Component implements shorthand methods for creating links to state. The same API is implemented by every Record class. All the methods below generally forward calls to the component.state. component.linkAt( 'key' ) Create the link for the state member key. Is a shortcut for component.state.linkAt() method. All records support linkAt() method as well. component.linkAll() Create links for all (or specified) the state members. All records support linkAll() method as well. component.links Direct access to the links cache. Can be used in event handlers to access the links created during the last render(). All links created for records (and for the component's state) are being cached. They are recreated only in case when their value has been changed. UI updates component.asyncUpdate() Safe version of the forceUpdate(). Gracefully handles component disposal and UI update transactions. Shall be used in place of every manual call to forceUpdate(). Events Component implements Events interface from the Type-R framework, thus it's able to trigger and subscribe for events.","tags":"","url":"API_Reference\/Component\/Other_members.html"},{"title":"Overview","text":"Link is an intermediate object used to implement the two-way data binding. It acts like a transport for the value, the callback to modify it, its validation error, abstracting out UI controls from the data representation in the state container and from the state container per se. Links to the record's attributes are commonly created with linkAt and linkAll methods of records. Record is automatically validated upon the links creation, and link encloses the validation error related to the particuler attribute. \/\/ Data bound control for the semantic form markup const Input = ({ valueLink, ...props }) =&gt; ( &lt;div className={`form-control ${ valueLink.error ? 'error' : '' }`}&gt; &lt;input {...props} value={ valueLink.value } onChange={ e =&gt; valueLink.set( e.target.value ) } \/&gt; &lt;div className=&quot;validation-error&quot;&gt;{ valueLink.error || '' }&lt;\/div&gt; &lt;\/div&gt; ); Links makes it possible to create the semantic markup for the form elements, encapsulating the all the required styles and validation error indication.","tags":"","url":"API_Reference\/Link\/Overview.html"},{"title":"Link structure","text":"Here are the most important link members. All the link members are read-only and should not be modified directly. \/\/ Link's shape { value : \/* the value *\/, set( newValue ){ \/* the function to change it *\/}, error : \/* validation error *\/ } link.value Holds linked value. This value is immutable. link.error Holds the validation error (typically the text error message) which might be consumed and displayed by data-bound countrol. An error is populated automatically on link creation when using linkAt() or linkAll() methods, and is produced by declarative validators from .has.check() attributes annotations. link.set( newValue ) Tells the state container to update the value. &lt;button onClick={ () =&gt; boolLink.set( !boolLink.value ) } \/&gt; link.update( prevValue =&gt; newValue ) Update link value using the given value transform function. &lt;button onClick={ () =&gt; boolLink.update( x =&gt; !x ) } \/&gt;","tags":"","url":"API_Reference\/Link\/Link_structure.html"},{"title":"Create the link","text":"All records and collections may create links to its elements. Component has the shorthand methods to create links to its state record elements. You can create custom link object encapsulating complex data binding logic with Link.value. object.linkAt( key ) record.linkAt( attr ) links the record's attribute. Semantically it's the reference to the attribute. collection.linkAt( prop ) links the custom collection property. Property's setter must modify some record's attributes or change collections. component.linkAt( key ) works similar to component.state.linkAt( key ). const nameLink = user.linkAt( 'name' ); object.linkAll() record.linkAll() links all records attributes. component.linkAll() works similar to component.state.linkAll(). \/\/ Link all attributes... const { name, email, age } = user.linkAll(); \/\/ Link specified attributes... const { name, email } = user.linkAll( 'name', 'email' ); collection.linkContains( record ) Create the boolean link which is true whenever the record is contained in the collection. Setting the link to false will remove record from the collection, setting it to true will add it. Link.value( value, set ) Create custom link with the given value and set function. Use the link.check method to populate the validation error.","tags":"","url":"API_Reference\/Link\/Create_the_link.html"},{"title":"Link transformations","text":"link.equals( value ) &lt;Checkbox checkedLink={ stringLink.equals( 'optionX' ) } \/&gt; &lt;Checkbox checkedLink={ stringLink.equals( 'optionY' ) } \/&gt; Create boolean equality link which value is true whenever link.value === value, and false otherwise. When an equality link is assigned with true the parent link value is set with value, and with null otherwise. Useful for radio groups. link.props &lt;input type=&quot;text&quot; {...nameLink.props} \/&gt; Converts the link to the standard { value, onChange } props to be easily consumed by standard &lt;input \/&gt; control. link.action( ( prevValue, event ) =&gt; newValue ) \/\/ simple click event handler... &lt;button onClick={ boolLink.action( x =&gt; !x ) } \/&gt; \/\/ manual binding to input control: const setValue = ( x, e ) =&gt; e.target.value; ... &lt;input value={ link.value } onChange={ link.action( setValue ) } \/&gt; Convert the link to the UI event handler event =&gt; void which will transform the link using the given function. link.action takes transform function, and produce a new function which takes single event argument. When it's called, event and link value are passes as transform parameters, and link will be updated with returned value. This is particularly useful in (but not restricted to) UI event handlers. link.check( predicate : value =&gt; boolean, errorMsg? ) Checks whenever the predicate is truthy on linked value, and if it's not, assigns link.error with errorMsg. Does nothing if link.error is already populated. This method may be used for additional validation in render(), and to populate the validation error for the custom links created with Link.value(). You typically don't need link.check for links created with linkAt() methods, because the validation happens inside of records.","tags":"","url":"API_Reference\/Link\/Link_transformations.html"},{"title":"Links to objects and arrays","text":"It's rather unusual scenario that you hold complex raw JS data as a part of your state, because typically the state is defined as a superposition of nested records and collections. Links can be used to make purely functional updates of the objects and arrays in records attributes. It's done with the help of at-links, which points to the elements of linked objects and arrays. link.at( key ) Create an at-link to the member of array or object. Whenever an at-link is updated, it will lead to proper purely functional update (with shallow copying) of the container (array or object). \/\/ Update this.state.array[ 0 ].name this.linkAt( 'array' ).at( 0 ).at( 'name' ).set( 'Joe' ); link.pick( key1, key2, ... ) Create at-links to the object's members with designated keys, and wrap them in an object. \/\/ Bulk create at-links for the linked object const { name, email } = objLink.pick( 'name', 'email' ); link.map( ( itemLink, itemKey ) =&gt; any | void ) Map and filter through the linked array or object to produce an array. Mapping function receives at-link to the corresponding element. Whenever it returns undefined, the corresponding element is be skipped. \/\/ Render the linked array... var list = stringArrayLink.map( ( itemLink, index ) =&gt; { if( itemLink.value ){ \/\/ Skip empty elements return ( &lt;div key={ index }&gt; &lt;Input valueLink={ itemLink } \/&gt; &lt;\/div&gt; ); } }); link.update( clonedObject =&gt; modifiedObject ) Update linked object or array. Plain objects and arrays are shallow copied already, thus it's safe just to update the value in place. \/\/ Update the linked object &lt;button onClick={ () =&gt; objLink.update( obj =&gt; { obj.a = 1; return obj; }) } \/&gt; link.action( ( clonedObject, event ) =&gt; Object ) Creates action to update enclosed object or array. Plain objects and arrays are shallow copied already, thus it's safe just to update the value in place. link.removeAt( key ) Remove element with a given key from the linked object or array. atLink.remove() Remove element with a given key from the linked object or array. Array-specific link methods linkToArray.splice() : void Similar to Array.splice() method, but performs purely functional update. linkToArray.push() : void Similar to Array.push() method, but performs purely functional update. linkToArray.unshift() : void Similar to Array.unshift() method, but performs purely functional update. linkToArray.contains( element ) Creates the boolean link to the presence of value in array. Resulting link value is true whenever element is present in array, and false otherwise. Whenever resulting link is assigned with new value, it will flip element in the array. Useful for the large checkbox groups.","tags":"","url":"API_Reference\/Link\/Links_to_objects_and_arrays.html"},{"title":"Overview","text":"Record is the serializable class with typed attributes, observable changes, and custom validation checks. It is the main building block for managing the application state; component local state, stores, and collection elements are all subclasses of the Record. In contrast to the &quot;model&quot; class in the majority of data frameworks, Record is not the key-value hash. It's the class with statically defined set of attributes of known types. Record itself is an abstract class. The subclass needs to be defined for every data structure of different shape, in a similar way as it's done in statically typed languages. import { define, Record } from 'type-r' \/\/ \u00e2\u00a4\u00b9 required to make magic work @define class User extends Record { \/\/ \u00e2\u00a4\u00b9 attribute's declaration static attributes = { firstName : '', \/\/ \u00e2\u009f\u00b5 String type is inferred from the default value lastName : String, \/\/ \u00e2\u009f\u00b5 Or you can just mention its constructor email : String.value( null ), \/\/\u00e2\u009f\u00b5 Or you can provide both createdAt : Date, \/\/ \u00e2\u009f\u00b5 And it works for any constructor. \/\/ And you can attach \u00e2\u00a4\u00b9 metadata to fine-tune attribute's behavior lastLogin : Date.value( null ).has.toJSON( false ) \/\/ \u00e2\u009f\u00b5 not serializable } } const user = new User(); console.log( user.createdAt ); \/\/ \u00e2\u009f\u00b5 this is an instance of Date created for you. const users = new User.Collection(); \/\/ \u00e2\u009f\u00b5 Collections are defined automatically. users.on( 'changes', () =&gt; updateUI( users ) ); \/\/ \u00e2\u009f\u00b5 listen to the changes. users.set( json, { parse : true } ); \/\/ \u00e2\u009f\u00b5 parse raw JSON from the server. users.updateEach( user =&gt; user.firstName = '' ); \/\/ \u00e2\u009f\u00b5 bulk update triggering 'changes' once","tags":"","url":"API_Reference\/Record\/Overview.html"},{"title":"Record basics","text":"Attribute declarations static attributes = { name : attrDef, ... } Record is a class with an observalbe and serializable public attributes. Attributes must be declared statically in static attributes class member, which is an object hash mapping an attribute name name to its declaration, encapsulating attribute type, default value, and metadata controlling different aspects of attribute behavior. @define class User extends Record { static attributes = { name : String.value( 'John Dow' ), email : 'john.dow@mail.com', \/\/ Same as String.value( 'john.dow@mail.com' ) address : String, \/\/ Same as String.value( '' ) } } The Record guarantee that every attribute will always hold the value of the declared type. Whenever the an attribute is being assigned with the value which is not compatible with its declared type, the type is being converted with an invocation of the constructor: new Type( value ) (primitive types are treated specially). attrDef name : Type.value( defaultValue ) The general form of type annotation is Type.value( defaultValue ), where the Type is the corresponding constructor function. attrDef name : Type When the function is used as attrDef, it's treated as the constructor function. Any constructor function may be used as an attribute type, if it behaves as converting constructor (like new Date( msecs )). attrDef name : defaultValue When other value than function is passed, it's treated as the default value and the type is being inferred form the value. If you need to pass function as the default value, use Function.value( theFunction ). Core Record API constructor( attrs?, options? ) When creating an instance of a record, you can pass in the initial values of the attributes, which will be set on the record. If {parse: true} is passed as an option, the attributes will first be converted by record's and attribute-level parse() before being set on the record. @define class Book extends Record { static attributes = { title : '', author : '' } } const book = new Book({ title: &quot;One Thousand and One Nights&quot;, author: &quot;Scheherazade&quot; }); record.initialize( attrs?, options? ) Called at the end of the Record constructor when all attributes are assigned and record's inner state is properly initialized. Takes the same arguments as a constructor. record.attrName Record's attributes may be directly accessed with record.name, as if they would be the members of the class. Please note, that you have to declare all attributes in static attributes declaration before use. @define class Account extends Record { static attributes = { name : String, ballance : Number } } const myAccount = new Account({ name : 'mine' }); myAccount.ballance += 1000000; \/\/ That works. Good, eh? record.set() Set a hash of attributes (one or many) on the record. If any of the attributes change the record's state, a change event will be triggered on the record. Change events for specific attributes are also triggered, and you can bind to those as well, for example: change:title, and change:content. @define class Note extends Record { static attributes = { title : '', content : '' } } const note = new Note(); note.set({title: &quot;March 20&quot;, content: &quot;In his eyes she eclipses...&quot;}); note.title = &quot;A Scandal in Bohemia&quot;; set() takes the standard set of transactional options.","tags":"","url":"API_Reference\/Record\/Record_basics.html"},{"title":"Aggregation tree","text":"Records can have attributes holding other Records and Collections, forming indefinitely nested data structures of arbitrary complexity. To create nested record or collection you should just mention its type in attribute's type annotation. import { Record } from 'type-r' @define class User extends Record { static attributes = { name : String, email : String, isActive : true } } @define class UsersListState extends Record { static attributes = { users : User.Collection } } All nested records and collections are aggregated by default and behave as integral parts of the containing record. Aggregated attributes are exclusively owned by the record, and taken with it together form an ownerhip tree. Many operations are performed recursively on aggregated elements: They are created when the owner record is created. They are cloned when the record is cloned. They are disposed when the record is disposed. They are validated as part of the record. They are serialized as nested JSON. attrDef attr : Type.shared Attributes can be marked as shared with adding Type.shared modifier. Such an attribute is not the member of record's aggregation\/ownership tree. It's initialized with null It's not cloned when the record is cloned (just the reference is copied over). It's not disposed when the record is disposed. It's not validated as part of the record (always valid by default) It's excluded from serialization. @define class UsersListState extends Record { static attributes = { users : User.Collection, selected : User.shared \/\/ can be assigned with the user from this.users } } record.getOwner() Return the reference to the record's owner, or null if record is not the part of aggregation tree. Due to the nature of aggregation, record may have one and only one owner. record.clone() Clone the record and all aggregated records and collections. The whole aggregation tree will be recursively cloned, references to shared members will copied. record.assignFrom( otherRecord ) Recursively assign the record and its aggregated members with values from otherRecord. This operation is similar to record.clone(), but instead of creation of the cloned record it makes an existing record to be the copy of other record. The whole aggregation tree will be recursively assigned, references to shared members will copied. record.dispose() Recursively dispose the record and its aggregated members. &quot;Dispose&quot; means that elements of the aggregation tree will unsubscribe from all event sources. It's crucial to prevent memory leaks in SPA. The whole aggregation tree will be recursively disposed, shared members won't.","tags":"","url":"API_Reference\/Record\/Aggregation_tree.html"},{"title":"Transactions and Events","text":"How record updates are processed Record changes occure in the scope of transactions. Record triggers the set of events during the transaction. Transaction is executed in three steps. Apply all the changes to the record and nested records and collections. Send change:[attribute] (record, value, options) events for each attribute which has been updated (including nested objects). If any of the model's attributes have changed: Send change (record, options) event. Notify record's owner on changes. So, the statement like user.name = 'Joe' will trigger two events: change:attr and the subsequent change. Statement user.set({ name : 'Joe', email : 'joe@mail.com' }) will (assuming that both attributes was changed) execute like this: New name and email values will be applied to the user. change:name and change:user events will be sent out. change event will be sent out. Any additional changes that may be applied to the record in change:[attribute] and change event handlers will be executed in the scope of the original transaction. It means, that: No additional change events will be triggered if you modify the record in change:[attribute] event handler (but new change:[attribute] events will). If the record will be modified in change event handler, there will be additional change events. However, record's owner will be notifyed only once when the wave of events and reactions will finish its processing. record.transaction( fun ) Execute the sequence of updates in fun function in the scope of the transaction, so it will trigger the single change event. Transactions are superior to record.set() in terms of both performance and flexibility. some.record.transaction( record =&gt; { record.a = 1; \/\/ `change:a` is triggered. record.b = 2; \/\/ `change:b` is triggered. }); \/\/ `change` is triggered. Listening to change events Events API attrDef attr : Type.has.watcher( 'methodName' ) attrDef attr : Type.has.watcher( function( value, name ){ ... } ) To attach some custom reaction on specific record's attribute change event, you attach the watcher function to this attribute. Watcher has the signature ( attrValue, attrName ) =&gt; void and is executed in the context of the record. Watcher internally listens to change:attr event which is triggered during the step 2. Therefore, no additional change events will be triggered. In the example below, any change of the name attribute will result in the subsequent update of the isAdmin attribute, and the singlechange event is triggered. @define class User extends Record { static attributes = { name : String.has.watcher( 'onNameChange' ), isAdmin : Boolean, } onNameChange(){ \/\/ Cruel. But we need it for the purpose of the example. this.isAdmin = this.name.indexOf( 'Admin' ) &gt;= 0; } } Helper functions Following API might be useful in change event listeners. record.changed The changed property is the internal hash containing all the attributes that have changed during its last transaction. Please do not update changed directly since its state is internally maintained by set(). A copy of changed can be acquired from changedAttributes(). record.changedAttributes( attrs? ) Retrieve a hash of only the record's attributes that have changed during the last transaction, or false if there are none. Optionally, an external attributes hash can be passed in, returning the attributes in that hash which differ from the record. This can be used to figure out which portions of a view should be updated, or what calls need to be made to sync the changes to the server. record.previous( attr ) During a &quot;change&quot; event, this method can be used to get the previous value of a changed attribute. @define class Person extends Record{ static attributes = { name: '' } } const bill = new Person({ name: &quot;Bill Smith&quot; }); bill.on(&quot;change:name&quot;, ( record, name ) =&gt; { alert( `Changed name from ${ bill.previous('name') } to ${ name }`); }); bill.name = &quot;Bill Jones&quot;; record.previousAttributes() Return a copy of the record's previous attributes. Useful for getting a diff between versions of a record, or getting back to a valid state after an error occurs.","tags":"","url":"API_Reference\/Record\/Transactions_and_Events.html"},{"title":"Validation","text":"Attribute-level validation checks attrDef attr : Type.has.check( predicate, errorMsg? ) Attribute-level validator. predicate : value =&gt; boolean is the function taking attribute's value and returning true whenever the value is valid. optional errorMsg is the error message which will be passed in case if the validation fail. If errorMsg is omitted, error message will be taken from predicate.error. It makes possible to define reusable validation functions. function isAge( years ){ return years &gt;= 0 &amp;&amp; years &lt; 200; } isAge.error = &quot;Age must be between 0 and 200&quot;; Attribute may have any number of checks attached, which are execute in sequence. Validation stops when first check in sequence fails. \/\/ Define new attribute metatype encapsulating validation checks. const Age = Number.has .check( x =&gt; x &gt;= 0, 'I guess you are a bit older' ) .check( x =&gt; x &lt; 200, 'No way man can be that old' ); attrDef attr : Type.isRequired The special case of attribute-level check cutting out empty values. Attribute value must be truthy to pass, &quot;Required&quot; is used as validation error. isRequired is the first validator to check, no matter in which order validators were attached. Validation API record.validate() Override in Record subclass to add record-level validation. Whatever is returned is treated as an error message. record.isValid() Returns true whenever the record is valid. The whole aggregation tree is validated. record.isValid( attrName ) Returns true whenever the record's attribute is valid. record.validationError Detailed validation error information, or null if the record and its aggregation tree is valid. An error object has tree structure mapping the invalid subtree of the aggregation tree. \/\/ ValidationError object shape { error : \/* record-level validation error msg as returned from record.validate() *\/, \/\/ Attribute-level validation errors, one entry for each invalid attribute. nested : { \/\/ Contains nested ValidationError object for nested records and collections... nestedRecord : \/* ValidationError *\/ nestedCollection : \/* ValidationError *\/ \/\/ ...and error msg for all other attributes. otherAttr : \/* attribute validation error as returned from .has.check() validator *\/ } } Validation error traversal ValidationError has a couple of methods for tree traversal. validationError.each( ( error, key ) =&gt; void ) Iterate through the records's errors (not recursive). key is null for the record-level validation error. validationError.eachError( ( error, key, recordOrCollection ) =&gt; void ) Recursively traverse aggregation tree errors. key is null for the record-level validation error. recordOrCollection is the reference to the current object.","tags":"","url":"API_Reference\/Record\/Validation.html"},{"title":"Serialization","text":"Attribute-level serialization control attrDef attr : Type.has.toJSON( false ) Exclude attribute from serialization. attrDef attr : Type.has.toJSON( ( value, name ) =&gt; json ) Override the default toJSON() method for the selected record's attribute. attrDef attr : Type.has.parse() Transform the data before it will be passed to the record's attribute when { parse : true } option is used. Serialization API record.parse( json ) May be overriden to transform constructor or set argument when { parse : true } option is used. constructor( json, { parse : true } ) Call record.parse( json ) and attribute-level parse transforms. They won't be executed by default. record.set( json, { parse : true } ) Call record.parse( json ) and attribute-level parse transforms. They won't be executed by default. record.toJSON() Create record's JSON representation. This can be used for persistence, serialization, or for augmentation before being sent to the server. The name of this method is a bit confusing, as it doesn't actually return a JSON string \u00e2\u0080\u0094 but I'm afraid that it's the way that the JavaScript API for JSON.stringify works. @define class Artist extends Record { static attributes = { firstName: String, lastName: String, birthday : Date, code : String.has.toJSON( x =&gt; x.toLowerCase() ) } } const artist = new Artist({ firstName: &quot;Wassily&quot;, lastName: &quot;Kandinsky&quot; }); artist.birthday = new Date( 1866, 12, 16 ); alert( JSON.stringify( artist ) ); It will, however, produce correct JSON for all the complex attribute types.","tags":"","url":"API_Reference\/Record\/Serialization.html"},{"title":"id  and id-references","text":"Record's id record.id Predefined record's attribute, the id is an arbitrary string (integer id or UUID). id is typically generated by the server. It is used in JSON for id-references. Records can be retrieved by id from collections, and there can be just one instance of the record with the same id in the particular collection. static idAttribute = 'attrName' A record's unique identifier is stored under the id attribute. If you're directly communicating with a backend (CouchDB, MongoDB) that uses a different unique key, you may set a Record's idAttribute to transparently map from that key to id. Record's id property will still be linked to Record's id, no matter which value idAttribute has. @define class Meal extends Record { static idAttribute = &quot;_id&quot;; static attributes = { _id : Number, name : '' } } const cake = new Meal({ _id: 1, name: &quot;Cake&quot; }); alert(&quot;Cake id: &quot; + cake.id); record.isNew() Has this record been saved to the server yet? If the record does not yet have an id, it is considered to be new. id-references Serializable references to shared records are called an id-references. It is represented as record.id in JSON, and there must be the populated master collection of records on the client in order to resolve ids on parse. There are two kinds of id-references: one-to-many, and many-to-many. They are declared with the special kind of attribute annotation. Id-references behaves in the same way as shared attributes, but inner changes in referenced objects are not observed. attrDef attr : Record.from( sourceCollection ) Declare an attribute to be the record from the particular collection. Serialized as record.id. attrDef attr : Collection.subsetOf( sourceCollection ) Declare an attribute to be the collection, which is the subset of the particular collection. Serialized as an array of record ids. Relative paths to source collection sourceCollection can be the string with the dot-separated relative object path to the collection. In this case, it is resolved dynamically relative to the record's this. @define class State extends Record { items : Item.Collection, selected : Record.from( 'items' ) \/\/ Will resolve to `this.items` }","tags":"","url":"API_Reference\/Record\/id_ and_id-references.html"},{"title":"Data-bound controls","text":"Link can be bound to the standard form control consuming value and onChange props using the link.props property: For the case of string control it's rather straightforward. \/\/ String &lt;input type=&quot;text&quot; {...link.props} \/&gt; &lt;textarea {...link.props} \/&gt; Checkbox can be bound to value either: directly, if the value is boolean. to the presense of the value in the array (array of flags), using the link.contains() method. to the presense of the record in the collection, using collection.linkContains() method. \/\/ Checkbox &lt;input type=&quot;checkbox&quot; {...boolLink.props } \/&gt; &lt;input type=&quot;checkbox&quot; {...arrayLink.contains( 'optionX' ).props } \/&gt; &lt;input type=&quot;checkbox&quot; {...collection.linkContains( record ).props } \/&gt; Radio groups can be bound to the single link, using link.equals() method. \/\/ Radio &lt;input type=&quot;radio&quot; {...link.equals( 'optionA' ).props } \/&gt; &lt;input type=&quot;radio&quot; {...link.equals( 'optionB' ).props } \/&gt; And the select list is bound to the single link in the same way as text inputs. \/\/ Select &lt;select {...link.props}&gt; &lt;option value=&quot;optionA&quot;&gt; A &lt;\/option&gt; &lt;option value=&quot;optionB&quot;&gt; B &lt;\/option&gt; &lt;\/select&gt; However, in order to take the full advantage of the value link pattern you're encouraged to create the semantic form control wrappers encapsulating the markup for inline validation errors and form layout styling. Not only the forms, but the most of UI can benefit of this technique. Linked UI controls This guide will explain how to create the custom data-bound (linked) controls with inline validation. Linked control is the React component following the simple pattern illustrated below. It takes the link as single property instead of the value and callbacks. It uses the link to extract the value and validation error, and to modify the value. \/\/ Custom data-bound control const Input = ({ link, ...props }) =&gt; ( &lt;div className={`form-row ${ link.error ? 'has-error' : '' } `}&gt; &lt;input type=&quot;text&quot; {...props} { ...link.props } \/&gt; &lt;div className=&quot;error-placeholder&quot;&gt;{ link.error || '' } &lt;\/div&gt; &lt;\/div&gt; ); \/\/ Another simple data bound control const Input = ({ link, ...props }) =&gt; ( &lt;input {...props} value={ link.value } onChange={ e =&gt; link.set( e.target.value ) } \/&gt; ); Custom tags mentioned in this guide are available as react-mvx\/tags. As it's hard to come up with the general solution for inline errors indication, this file is rather intended to be used as a starting boilerplate for your controls. import { Input } from 'react-mvx\/tags' Text input controls tags.jsx contains wrappers for standard &lt;input&gt; and &lt;textarea&gt; tags, which consume linked strings. These wrappers add invalid class to enclosed HTML element if an error is present in the link, and required class if isRequired validator is the failing one. import { Input, TextArea } from 'react-mvx\/tags' ... &lt;Input type=&quot;text&quot; valueLink={ link } \/&gt; &lt;TextArea valueLink={ link } \/&gt; Its implementation is rather straightforward. Numeric input In some cases you can use the wrong input rejection instead of (or in addition to) the validation. The most popular example is the numeric-only input control. It guarantees that the linked value will only be updated with the valid number, completely encapsulating all related checks and mechanics. The challenge here is that when number in not an integer it has to go throgh the sequence of intermediate invalid states during the editing process. Like &quot;&quot; -&gt; &quot;-&quot; -&gt; &quot;-0&quot; -&gt; &quot;-0.&quot; -&gt; &quot;-0.5&quot;. The proper implementation of wrong input rejection might be tough. tags.jsx contains the cross-browser numeric input tag. It has following differences compared to the regular &lt;Input&gt;: Keyboard input which obviously leads to invalid values (e.g. letters) is rejected. Link value is guaranteed to be the valid number. There are integer and positive boolean props controlling input rejection. They can be combined. &lt;NumberInput&gt; validates its intermediate state and adds invalid class to enclosed input element if it's not a number. import { NumberInput } from 'react-mvx\/tags' &lt;NumberInput valueLink={ link } \/&gt; &lt;NumberInput valueLink={ link } integer={ true }\/&gt; &lt;NumberInput valueLink={ link } positive={ true }\/&gt; Checkboxes There are different ways how you can handle the checkbox components. The problem of the standard checkbox control, though, is that it's not that easily styled. tags.jsx contains the custom checkbox and radio components implemented using the plain &lt;div \/&gt; element which toggles selected class on click. By default, it has checkbox CSS class, which can be overridden by passing className prop. It passes through anything else, including children. &lt;Checkbox checkedLink={ booleanLink } \/&gt; &lt;Checkbox checkedLink={ arrayLink.contains( 'option' ) } \/&gt; Radio Groups There are two different ways how you can approach the data binding for the radio groups. First option is to pass the value of the particular option along with the link. Link this: &lt;label&gt; A: &lt;Input type=&quot;radio&quot; valueLink={ flagLink } value=&quot;a&quot; \/&gt; &lt;\/label&gt; &lt;label&gt; B: &lt;Input type=&quot;radio&quot; valueLink={ flagLink } value=&quot;b&quot; \/&gt; &lt;\/label&gt; Alternatively, you can use link.equals( value ) method to produce the boolean link which is specially designed to create radio groups, as it's illustrated by the custom &lt;Radio \/&gt; tags from the tags.jsx. Internally, it's &lt;div&gt; element which always sets its link to true on click. And whenever the link value is true, it adds selected class to the div. By default, it has radio CSS class, which can be overridden by passing className prop. It passes through anything else, including children. &lt;label&gt; A: &lt;Radio checkedLink={ flagLink.equals( 'a' ) } \/&gt; &lt;\/label&gt; &lt;label&gt; B: &lt;Radio checkedLink={ flagLink.equals( 'b' ) } \/&gt; &lt;\/label&gt;","tags":"","url":"Data-bound controls.html"},{"title":"Examples","text":"","tags":"","url":"Examples.html"},{"title":"api","text":"Component API React-MVx requires React as peer dependency and exports extended React namespace, which is supposed to be used in place you would normally use React. import React from 'react-mvx' This document describes an extended API only. Component Every component definition in React-MVx must start with @define decorator. static props : { [ name ] : TypeAnnotation } Component props declaration. Replaces standard PropTypes. Type annotation syntax: Constructor - puts the instanceOf constraint on props type. Use Number, String, and Boolean for primitive types. Constructor.value( val ) or just val - property has the default value. Constructor.isRequired - property is mandatory. RecordOrCollection.has.changeEvents( true ) - update the component on any inner change in the property. EventSource.has.changeEvents( 'event1 event2 ...' ) - update the component on any of the specified events triggered by the property. EventSource.has.events({ [ events ] : handlerFunction | 'methodName' }) - subscribe for events from the property. Constructor.has.watcher( watcherFunction | 'methodName' ) - call the watcher when new prop value is received. Type annotations listed above may be chained. static pureRender : true Generate and attach the &quot;pure render&quot; optimization mixin. Mixin prevents the subsequent render calls in case if props were unchanged. Mixin detects and takes into account inner changes of records and collections as well. static props declaration is required for pureRender to work. Only declared props will be compared. static state : { [ name ] : TypeAnnotation } | RecordConstructor Component state declaration. State is modeled as Record either referenced by Constructor or imlicitly defined with a given attributes declaration. state Record is created before the component mount, and is disposed when component is unmounted. Constructor - initialize attribute with the default value of the given constructor. Constructor.value( val ) or just val - provide different default value. Constructor.isRequired - put 'not empty' validation check on the attribute. Constructor.has.check( predicate ) - put custom validation check on the attribute. RecordOrCollection.has.changeEvents( false ) - do not update the component on any inner changes of the attribute. EventSource.has.events({ [ events ] : handlerFunction | 'methodName' }) - subscribe for events from the attribute. Constructor.has.watcher( watcherFunction | 'methodName' ) - call the watcher when the attribute is changed. Type annotations listed above may be chained. Please, refer to the [Type-R] type annotations reference for the complete list of options. state : Record Replaces standard React's state and setState. Holds an object of the Record subclass. Use direct assignments to modify the state: this.state.x = 5; Use transaction() call to groupe the sequence of changes in single UI update transaction. transaction( fun ) Group the sequence of state (and props) updates in the single transaction leading to single UI update. this.transaction( state =&gt; { state.a++; state.b++; this.props.collection.reset(); }); Read more about transactions in Type-R manual. static store : { [ name ] : TypeAnnotation } | Store | StoreConstructor Stores in Type-R are internally similar to the Record and used to resolve one-to-many and many-to-many relationships by id. Stores must not be used to store UI state; they are intended to hold the shared domain state which is cross-referenced by id. There may be many stores in Rect-MVx. There is the single default store (Store.global) which is used to cache the data which must be accessible across the pages. Specifying the store for the top-level component sets this store as the primary one for all the internal state of the current component subtree. static store = referenceToTheExistingStore. Update the UI on store changes. static store = StoreConstructor. Creates the local store with the lifetime bound to the component's one. static store = { attributes }. Implicitly create the Store subclass from the given attribute spec. store : Store When the static store is defined, provide the access to the store in component. Store is not directly accessible to the subcomponents; you have to pass values down as props. static context : { [ name ] : TypeAnnotation } Replacement for standard contextTypes. Just Constructor may be used as type annotation. static childContext : { [ name ] : TypeAnnotation } Replacement for standard childContextTypes. Just Constructor may be used as type annotation. getChildContext() function is required to create the context as in raw React. linkAt( 'key' ) : Link Create the value link for the state member key. All records support linkAt() method as well. linkAll() : { [ name ] : Link } Create the value links for all (or specified) the state members. All records support linkAll() method as well. asyncUpdate() Safe version of the forceUpdate(). Gracefully handles component disposal and UI update transactions. Shall be used in place of every manual call to forceUpdate(). Link Reference to NestedLink's Link class. assignToState( key ) Create props watcher which assign the property content to the given local state member. @mixin( A, B, ... ) Old good React mixins.","tags":"","url":"includes\/api.html"},{"title":"complex-state","text":"The complex state The complex state (being opposed to the flat state) is the state composed of nested parts. In raw React it would look like this: state = { \/\/ In React-MVx you would need to add 'static' in the beginning obj : { x : 1 }, arr : [ { text : &quot;Hello&quot; } ] }; While React-MVx can store plain JS objects and arrays in state attributes, they will remain plain object and arrays. Contrary to mobx, it does nothing magical to make plain JS objects observable. It will detect changes, though, if you will use value links to modify the content of such an attributes. this.state.obj.x = 2; \/\/ &lt;- Won't detect the change this.linkAt( 'obj' ).at( 'x' ).set( 2 ); \/\/ &lt;- It will, and it will update UI. But working with a raw JS structures is not the major use case it's designed for. You will rarely need it. Because the strength of the React-MVx lies in the way how it works with classes. Class constructors in state attributes In React-MVx state all attributes are typed. State definition is not really the set of the default values, but rather its type annotation. In order to put the class in the state attribute you should use its constructor in place of the default value. static state = { time : Date } When the state Record will be created, new Date() will be invoked to initialize this.state.time. You may pass the default value to constructor like this (which is the general form of type annotation). null as default value won't invoke the constructor but assign an attribute to null instead. static state = { time : Date.value( 6867836478 ), updated : Date.value( null ) \/\/ &lt;- updated = null } When something other than function is passed, React-MVx treats it as a default value and extracts its constructor (type) from the value. It applies to primitive types as well. Following attribute definitions are equivalent: static state = { text : '', text : String text : String.value( '' ) } React-MVx uses attribute type information in numerous ways. One of them is the run-time type assertion and convertion. It's guaranteed that the particuar Record's attribute will always has the value of the declared type. this.state.textAttr = 5; \/\/ will be converted to &quot;5&quot; this.state.boolAttr = a &amp;&amp; b \/\/ guaranteed to be true or false or null Nested Records Back to our example from the beginning, nested Records and Collections classes are used to describe an appication state instead of nested objects and arrays. static state = { obj : { x : 1 }, arr : [ { text : &quot;Hello&quot; } ] }; First, let's wrap the obj state member in a Record. To do that, we need to create the Record subclass, like this: @define class MyObj extends Record { static attributes = { x : 1 } } Or, just the one-liner which does entirely the same thing... const MyObj = Record.defaults({ x : 1 }); Now we have the constructor of the observable object with an attribute x which has the default value of 1. All we have to do, is to fix our state definition: static state = { obj : MyObj, \/\/ &lt;- !!! arr : [ { text : &quot;Hello&quot; } ] }; If we don't need to reference MyObj anywhere else, we could make an inline Record definition: static state = { obj : Record.defaults({ x : 1 }), arr : [ { text : &quot;Hello&quot; } ] }; Now, the direct assigment this.state.obj.x = 2 will be detected by React-MVx and it will update the UI. Record's Collections When we have the Record subclass, the its collection's constructor is obtained with MyRecord.Collection: const Text = Record.defaults({ text : &quot;Hello&quot; }); ... static state = { obj : Record.defaults({ x : 1 }), arr : Text.Collection }; Contrary to the records, collection doesn't behave like the plain array. It behaves almost identical to the Backbone Collection. If you're familiar with Backbone, you already know how to deal with this thing. Refer to the API Reference for the details. However, the arr collection will be created empty because we provide nothing but its constructor. To fix that, we need to pass its default values. static state = { obj : Record.defaults({ x : 1 }), arr : Text.Collection.value([ { text : &quot;Hello&quot;}, { text : &quot;World!&quot; }]) };","tags":"","url":"includes\/complex-state.html"},{"title":"databinding.1","text":"Data bound controls An essense of the &quot;data binding&quot; pattern is that the inner state of the UI control is mapped to some value in the application data layer. Whenever the value change, it's synchronized in both directions. Almost all modern JS frontend application frameworks supports two-way data binding out of box. React-MVx has the first-class support for the two-way data binding though the concept of value links. It's best to understand it on the example. Data-bound controlled input component In this example we will bind the state member to the input control. In order to use data binding you need to import data bound input controls from react-mvx\/tags module first. import { Component, define } from 'react-mvx' import { Input } from 'nestedreact\/tags' Then, you can create the controlled input component like this: @define export class MyComponent extends Component { static state = { text : '' } render(){ return &lt;Input valueLink={ this.linkAt( 'text' ) } \/&gt;; } } If you have a form with a lot of controls, you can create links in a bulk with a single line using model.linkAll() method. This is the preferable way of dealing with the complex forms. @define export class MyComponent extends Component { static state = { a : '', b : '', c : '' } render(){ const links = this.linkAll(); return ( &lt;form&gt; &lt;Input valueLink={ links.a } \/&gt; &lt;Input valueLink={ links.b } \/&gt; &lt;Input valueLink={ links.c } \/&gt; &lt;\/form&gt; ); } } Under the hood To explain valuelink pattern simply, is an object holding the value and the callback to update the value. It is something close to this: render(){ const link = { value : this.state.text, set : x =&gt; this.state.text = x }; return &lt;Input valueLink={ link } \/&gt;; } And, an Input control which consumes such a link would look like this: const Input = ({ valueLink }) =&gt; ( &lt;input value={ valueLink.value } onChange={ e =&gt; valueLink.set( e.target.value ) \/&gt; ); React-MVx link implementation works close to the code above but is way more advanced. Refer to the NestedLink package documentation for more information about the data binding capabilities.","tags":"","url":"includes\/databinding.1.html"},{"title":"simple","text":"State management 101 It's not a secret that the standard React component state is not very suitable and pleasant thing work. But it doesn't have to be so. The first and the most important thing React-MVx does is that it replaces React state with the universal state container which is called Record. It's 'universal' because it's used to handle all the state in the application, no matter is it the local UI state, domain state, or the shared state in the global store. Technically, the &quot;store&quot; in React-MVx is the subclass of the Record just as local UI state is. And the best part about the global store is that in the majority of cases you don't need it. Simple stateful component React-MVx extends React namespace so you need to use it instead of React. import { define, Component } from 'react-mvx' Definition of the React-MVx component must be preceded with @define decorator. @define export class MyComponent extends Component { render(){ return ( \/* jsx *\/ ) } } Then we define the state. In the simplest case, the state definition looks similar to the standard React state initialization, but you need to preced it with static. Contrary to the React state, all state attributes you're going to use must be declared. We will have just one state member - the counter. @define class MyComponent extends Component { static state = { count : 0 }; render(){ return ( \/* jsx *\/ ) } } And then, you just access this.state as if it would be the plain object. render(){ const { state } = this; return ( &lt;div onClick={ () =&gt; state.count++ }&gt; { state.count } &lt;\/div&gt; ); } Fairly simple. The more subtle difference to the React state is that the changes to the state are applied immediately, while the subsequent UI update may happen asynchronously. Now, it's time to understand what really happens behind the scene inside of the @define decorator and how this example works. Under the hood First, @define looks for the state static variable. If it present, it creates the Record subclass with attributes specification taken from this variable. So, something like this happens behind the scene: @define class MyState extends Record { static attributes = { count : 0 } } @define class MyComponent extends Component { static state = MyState; render(){ return ( \/* jsx *\/ ) } } Record is the base class for the universal state container. It behaves as normal class, but whatever is listed in its static attributes member will become its observable and serializable properties. Then, @define will attach special mixin to your component which will create an instance of the MyState before mount, will start listening to its changes and updating the UI after the first render (and will dispose it when the component will be unmounted). It works as if you would have the following code in your component: componentWillMount(){ \/\/ Works before your componentWillMount will be called. this.state = new MyState(); } componentDidMount(){ \/\/ Works before your componentDidMount is called. this.state.on( 'change', () =&gt; this.forceUpdate() ); } Therefore, you may read and write the members of you state directly. Any write operation will emit change event and trigger the UI update.","tags":"","url":"includes\/simple.html"}]}