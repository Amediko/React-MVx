{"pages":[{"title":"React-MVx","text":"React-MVx bridges the gap between React and traditional MVx architecture, combining the powerful OO state management and two-way data binding with all the benefits of the unidirectional data flow. Type-R for &quot;M&quot; and &quot;VM&quot; Single technique to manage UI and domain state. State is observable and serializable by default. Declarative validation and run-time schema checks. 10 times faster than BackboneJS. React for &quot;V&quot; Handle forms naturally: Two-way data binding Transparent validation Cuts your code size 2-5x compared to React\/Redux. Choose your &quot;C&quot; react-router No router Whatever-you-like router","tags":"","url":"index.html"},{"title":"Getting Started","text":"","tags":"","url":"Getting_Started.html"},{"title":"Data binding and forms","text":"In this tutorial we will learn the state management and two-way data binding basics on the example of the simple user info editing form. Our form will be the simple stateful component holding the state of the form in its local state, and for the purpose of the illustration storing its state in the browser's localStorage. Defining the stateful component React-MVx extends React namespace and must be used instead of React. The most important class it exports is the modified Component. The general definition of the stateful component looks like this: import React, { define } from 'react-mvx' import ReactDOM from 'react-dom' @define class Application extends React.Component { static state = { \/* state attributes definition *\/ }; render(){ return ( \/* jsx *\/ ); } } ReactDOM.render( &lt;Application\/&gt;, document.getElementById( 'react-application' ) ); There are few differences to raw React so far: Component definitions (as all React-MVx definitions) must be preceded with the @define decorator. The state is not assigned in the constructor, but declaratively defined in class definition. Declaring the state In the simplest case like ours when the state is flat and consists of primitive types, the state definition looks like the plain object. We list state attributes accompanied with their default values. static state = { name : '', email : '', isActive : true }; This declaration will lead to an automatic creation of the observable component.state object of the similar shape when the Application component will be mounted. No need to initialize the state in the constructor. No need for component.setState() either; plain assignments to the component.state members will be detected and will lead to the component's render. Which is cute, but we won't need any explicit state modifications in this example. Because we have two-way data binding. Adding the form's markup Now it's the time to create the markup for our form using the standard React's &quot;controlled components&quot;. Controlled components do not have their own local state; it's mapped to some external state container. In React-MVx this mapping is done with links. Think of link in this example as an object-reference to the state's attribute. link.props return the value\/onChange props pair which is expected by standard controlled form components. render(){ \/\/ Link the state... const { name, email, isActive } = this.linkAll(); return ( &lt;form&gt; &lt;label&gt; Name: &lt;input type=&quot;text&quot; { ...name.props }\/&gt; &lt;\/label&gt; &lt;label&gt; Email: &lt;input type=&quot;text&quot; { ...email.props }\/&gt; &lt;\/label&gt; &lt;label&gt; Is active: &lt;input type=&quot;checkbox&quot; { ...isActive.props }\/&gt; &lt;\/label&gt; &lt;\/form&gt; ); } At this stage, we have an editable form. Adding the persistent state We would like to store the state of our form in the browser's localStorage. &quot;Save&quot; button must save the state, while &quot;Cancel&quot; must return the form to its default state. First of all, lets add these buttons: render(){ ... return ( &lt;form onSubmit={ this.onSubmit }&gt; ... &lt;button type=&quot;submit&quot;&gt;Save&lt;\/button&gt; &lt;button type=&quot;button&quot; onClick={ this.onCancel }&gt; Clear &lt;\/button&gt; &lt;\/form&gt; ); } We want &quot;Cancel&quot; button to set out state to its defaults, which is represented in the code quite literally: onCancel = () =&gt; this.state.set( this.state.defaults() ); And the &quot;Save&quot; button must save the state to the localStorage. Good news is that all the state in React-MVx is serializable by default. onSubmit = () =&gt; localStorage.setItem( 'users-form', JSON.stringify( this.state ) ); Now, all we have to do is to restore the state on load. Which is done in the standard React's componentWillMount lifecycle hook. componentWillMount(){ const json = JSON.parse( localStorage.getItem( 'users-form' ) || '{}' ); this.state.set( json, { parse : true } ); } That's really it. Here are the complete sources of our example, and here you can see the example working. API used in the example static state = { attrName : attrDef, ... } component.state Local component's state. record.set( data, options? ) Component's state is actually modeled with the Type-R's Record. record.set() method is used to bulk update the state, { parse : true } option means that data is the raw JSON and needs to be processed accordingly. record.toJSON() This method was implicitly called in JSON.stringify( this.state ) );. There are more details on Type-R serialization in its docs. component.linkAll() Method is used to create the links for the state attributes. Read more about links in docs. link.props Transforms the link to the controlled component's value\/onChange props pair. Read more about data binding in docs.","tags":"","url":"Guides\/Data_binding_and_forms.html"},{"title":"Input Validation","text":"Previous example + state validation.","tags":"","url":"Guides\/Input_Validation.html"},{"title":"Editable Lists","text":"Users list example. Collections, state synchronization. Edit Dialog pattern.","tags":"","url":"Guides\/Editable_Lists.html"},{"title":"Paging","text":"Page pattern on the example of users list.","tags":"","url":"Guides\/Paging.html"},{"title":"id-references and stores","text":"Users and roles with many-to-many relationship. Read-only roles in store.","tags":"","url":"Guides\/id-references_and_stores.html"},{"title":"Layered application state","text":"Demonstrate the three levels of the state. Users and Roles pages example. Read-only global store. Mutable page-level store. Local component state.","tags":"","url":"Guides\/Layered_application_state.html"},{"title":"Overview","text":"React-MVx is built around the idea of universal state management featuring the same technique to manage the local component state, application page state, and the global application state. Basic building blocks of the application architecture are: React-MVx Component (extended React.Component) for the view layer. Records and Collection (provided by Type-R data framework) for managing all kinds of an application state. Links for two-way data binding. Stores (which is the subclass of the Record and can be dynamically created) for resolving record's id-references. React-MVx Component uses the Record class to manage its local state. Record can consists of other records and collections, describing the data structure of arbitrary complexity. All records are serializable by default, has deeply observable changes, and supports the declarative validation. The behavior of record's attributes and component state\/props elements is controlled with declarative type annotations. React-MVx extends React namespace and should be used instead of react. All class Component definitions must be preceeded with the @define decorator. import React, { define } from 'react-mvx' @define class HelloApp extends React.Component { static state = { count : 0 }; render(){ const { state } = this; return ( &lt;h1 onClick={ () =&gt; state.count++ }&gt; Hi there! { state.count } &lt;\/h1&gt;; ); } }","tags":"","url":"Overview.html"},{"title":"Overview","text":"React-MVx UI Component React-MVx extends React namespace and should be used instead of react. All class Component definitions must be preceeded with the @define decorator. All features of the Component are controlled through the unified property and attribute declarations. import React, { define } from 'react-mvx' @define class Hello extends React.Component { static props = { \/\/ instead of `propTypes` and `defaultProps` propName : `propDef`, ... } static context = { \/\/ instead of `contextTypes` propName : `propDef`, ... } static childContext = { \/\/ instead of `childContextTypes` propName : `propDef`, ... } static state = { \/\/ instead of &quot;this.state = &quot; in the constructor. attrName : `attrDef`, ... } static store = { \/\/ store attrName : `attrDef`, ... } render(){...} } propDef and attrDef cheat sheet The majority of React-MVx features are controlled with declarative props, state, store, and context type annotations. Everything (state, store, props, and context) Type annotations below represents the run-time type assertions. Annotation Description Ctor element has specified type Ctor.isRequired element is required Ctor.has.check(...) custom validation check state, store, and props You can specify the default value for an attribute or prop, and reactions on its change. Annotation Description Ctor.value( defaultValue ) element has default value defaultValue element has default value Ctor.has.watcher(...) custom reaction on element's change Ctor.has.events(...) listen to custom events from the element Ctor.has.changeEvents(...) update on element's changes state and store You have an an attribute-level control of the serialization and ownership for the state, store, and records attributes. Annotation Description Record.shared attribute holds the reference to the record Collection.Refs collection of references to the records Record.from(...) reference to the record from the specified collection Collection.subsetOf(...) collection of references to the records from the specified collection Ctor.has.parse(...) custom parse hook Ctor.has.toJSON(...) custom serialization hook Ctor.has.get(...) attribute read hook Ctor.has.set(...) attribute write hook Ctor.has.metadata(...) attach custom metadata to the attribute","tags":"","url":"Component\/Overview.html"},{"title":"props","text":"Component static props declaration replaces standard React's propTypes and defaultProps. Declarations static props = { name : propDef, ... } Declare component props. Declaration is an object import React, { define } from 'react-mvx' @define class PropsDemo extends React.Component { static props = { name : Declaration, ... } } static pureRender = true Prevents subsequent render calls in case if props were unchanged. It's known as &quot;pure render&quot; optimization. Inner changes of records and collections are detected and taken into account. Thus, it works properly with mutable records and collections. static props declaration is required for pureRender to work. Only declared props will be tracked and compared. Properties definitions propDef name : Constructor Checks if component prop is an instance of the Constructor and puts the warning to the console if the prop type is not compatible. propDef name : Constructor.isRequired Mark property as required. import React, { define } from 'react-mvx' @define class PropsDemo extends React.Component { static props = { \/\/ Simple form of annotation is just the constructor function designating the type. optionalArray: Array, optionalBool: Boolean, optionalFunc: Function, optionalNumber: Number, optionalObject: Object, optionalString: String, optionalSymbol: Symbol, \/\/ Anything that can be rendered: numbers, strings, elements or an array \/\/ (or fragment) containing these types. optionalNode: React.Node, \/\/ A React element. optionalElement: React.Element, \/\/ You can also declare that a prop is an instance of a class. optionalMessage: Message, \/\/ You can chain any of the above with `isRequired` to make sure a warning \/\/ is shown if the prop isn't provided. requiredFunction : Function.isRequired }; ... } propDef name : Constructor.value( defaultValue ) Assign default property value. propDef name : defaultValue Assign default property value. The the type will be inferred from the defaultValue. Any function in props annotation is treated as a constructor. Thus, Function.value( defaultValue ) must be used to specify the defaults for functions. import React, { define } from 'react-mvx' @define class PropsDemo extends React.Component { static props = { withDefault : String.value( 'defaultValue' ), anotherDefault : 'defaultValue' } } propDef name : Constructor.has.watcher( 'componentMethodName' ) propDef name : Constructor.has.watcher( function( newValue, name ){ ... } ) Watcher is the function which is called when the particular prop is assigned with new value. Watcher is called after componentWillMount, and may be called during componentWillReceiveProps if the property is changed. Watcher is executed in the context of the component. import React, { define } from 'react-mvx' @define class PropsDemo extends React.Component { static props = { first : String.has.watcher( 'onFirstChange' ), second : Number.has.watcher( second =&gt; console.log( 'Received new prop:', second ) ) } onFirstChange( newValue, name ){ console.log( 'First prop is about to change:', newValue ); } } propDef name : RecordOrCollection.has.changeEvents( true ) Observe internal changes of the record or collection and update the component in case of changes. propDef name : EventSource.has.changeEvents( 'event1 event2 ...' ) Update the component in case if property triggers any of the listed events. import React, { define } from 'react-mvx' import { Record } from 'react-mvx' @define class PropsDemo extends React.Component { static props = { \/\/ Render on every change trackInnerChanges : Record.has.changeEvents( true ), \/\/ Render when record is added to or removed from the collection anotherDefault : Collection.has.changeEvents( 'add remove' ) } } propDef name : EventSource.has.events({ event : handler, ... }) Subscribe for events from the component property. handler can either be the name of the component's method, or the function handling the event. Handler is executed in the context of the component.","tags":"","url":"Component\/props.html"},{"title":"state","text":"Component's state is modeled as Type-R Record. Record is created before componentWillMount() and disposed after componentWillUnmount(). All changed inside of the state record are observed, and the component is updated in case of change. Declarations static state = RecordConstructor Define stateful component with the state Record declared externally. static state = { name : attrDef, ... } Implicitly define state Record with a given attributes declaration. All declarations working on props works for the state as well. Refer to the Record documentation for the attributes declaration syntax. Class members component.state Holds an object of the Record subclass. Do not use component.setState(). Use direct assignments to modify the state: this.state.x = 5; Refer to the Record documentation for the complete list of methods. component.transaction( fun ) Group the sequence of state (and props) updates in the single transaction leading to single UI update. this.transaction( state =&gt; { state.a++; state.b++; this.props.collection.reset(); }); Read more about transactions in Record's manual.","tags":"","url":"Component\/state.html"},{"title":"store","text":"Stores in Type-R are internally similar to the Record and used to resolve one-to-many and many-to-many relationships by id. Stores must not be used to store UI state; they are intended to hold the shared domain state which is cross-referenced by id. There may be multiple stores in Rect-MVx. There is the single default store (Store.global) which is used to cache the data that must be accessible across the pages. Specifying the store for the top-level component sets this store as the primary one for all the internal state of the current component subtree. Declarations static store = existingStore Expose the existingStore to the component subtree. Update component on store changes. static store = StoreConstructor Creates the local store on component's mount and dispose it when component is unmounted. Expose the store to the component subtree. Update component on store changes. static store = { attrName : attrDef, ... } Implicitly create the Store subclass from the given attribute spec. Accepts the same attrDef as the state and Record. Class members component.store When the static store is defined, provide the access to the store in component. Store is not directly accessible to the subcomponents; you have to pass values down as props.","tags":"","url":"Component\/store.html"},{"title":"context","text":"Static context and childContext declarations replaces React's standard contextTypes and childContextTypes. Declarations static context = { name : propDef, ... } Replacement for standard contextTypes. static childContext = { name : propDef, ... } Replacement for standard childContextTypes. getChildContext() function is required to create the context as in raw React. Properties definitions Subset of static props declaration is supported for the context propDef. propDef name : Constructor Checks whenever the value is an instance of the Constructor and puts the warning to the console if the prop type is not compatible. propDef name : Constructor.isRequired Value is required.","tags":"","url":"Component\/context.html"},{"title":"Other members","text":"Links to state Component implements shorthand methods for creating links to state. The same API is implemented by every Record class. All the methods below generally forward calls to the component.state. component.linkAt( 'key' ) Create the link for the state member key. Is a shortcut for component.state.linkAt() method. All records support linkAt() method as well. component.linkAll() Create links for all (or specified) the state members. All records support linkAll() method as well. component.links Direct access to the links cache. Can be used in event handlers to access the links created during the last render(). All links created for records (and for the component's state) are being cached. They are recreated only in case when their value has been changed. UI updates component.asyncUpdate() Safe version of the forceUpdate(). Gracefully handles component disposal and UI update transactions. Shall be used in place of every manual call to forceUpdate(). Events Component implements Events interface from the Type-R framework, thus it's able to trigger and subscribe for events.","tags":"","url":"Component\/Other_members.html"},{"title":"Overview","text":"Link is an intermediate object used to implement the two-way data binding. It acts like a transport for the value, the callback to modify it, its validation error, abstracting out UI controls from the data representation in the state container and from the state container per se. Links to the record's attributes are commonly created with linkAt and linkAll methods of records. Record is automatically validated upon the links creation, and link encloses the validation error related to the particuler attribute. \/\/ Data bound control for the semantic form markup const Input = ({ valueLink, ...props }) =&gt; ( &lt;div className={`form-control ${ valueLink.error ? 'error' : '' }`}&gt; &lt;input {...props} value={ valueLink.value } onChange={ e =&gt; valueLink.set( e.target.value ) } \/&gt; &lt;div className=&quot;validation-error&quot;&gt;{ valueLink.error || '' }&lt;\/div&gt; &lt;\/div&gt; ); Links makes it possible to create the semantic markup for the form elements, encapsulating the all the required styles and validation error indication.","tags":"","url":"Link\/Overview.html"},{"title":"Link structure","text":"Here are the most important link members. All the link members are read-only and should not be modified directly. \/\/ Link's shape { value : \/* the value *\/, set( newValue ){ \/* the function to change it *\/}, error : \/* validation error *\/ } link.value Holds linked value. This value is immutable. link.error Holds the validation error (typically the text error message) which might be consumed and displayed by data-bound countrol. An error is populated automatically on link creation when using linkAt() or linkAll() methods, and is produced by declarative validators from .has.check() attributes annotations. link.set( newValue ) Tells the state container to update the value. &lt;button onClick={ () =&gt; boolLink.set( !boolLink.value ) } \/&gt; link.update( prevValue =&gt; newValue ) Update link value using the given value transform function. &lt;button onClick={ () =&gt; boolLink.update( x =&gt; !x ) } \/&gt;","tags":"","url":"Link\/Link_structure.html"},{"title":"Create the link","text":"All records and collections may create links to its elements. Component has the shorthand methods to create links to its state record elements. You can create custom link object encapsulating complex data binding logic with Link.value. record.linkAt( attr ) Create the link to the record's attribute. Semantically it's the reference to the attribute. const nameLink = user.linkAt( 'name' ); collection.linkAt( prop ) Create the link to the custom collection property. Property's setter must modify some record's attributes or change the collection. component.linkAt( key ) Create the link to the attribute of the conponent's state. Works similar to component.state.linkAt( key ). record.linkAll() Link all (or listed) records' attributes. \/\/ Link all attributes... const { name, email, age } = user.linkAll(); \/\/ Link specified attributes... const { name, email } = user.linkAll( 'name', 'email' ); component.linkAll() Link all (or listed) attributes of the component's state. Works similar to component.state.linkAll(). collection.linkContains( record ) Create the boolean link which is true whenever the record is contained in the collection. Setting the link to false will remove record from the collection, setting it to true will add it. Link.value( value, set ) Create custom link with the given value and set function. Use the link.check method to populate the validation error.","tags":"","url":"Link\/Create_the_link.html"},{"title":"Link transformations","text":"link.equals( value ) Create boolean equality link which value is true whenever link.value === value, and false otherwise. When an equality link is assigned with true the parent link value is set with value, and with null otherwise. &lt;Checkbox checkedLink={ stringLink.equals( 'optionX' ) } \/&gt; &lt;Checkbox checkedLink={ stringLink.equals( 'optionY' ) } \/&gt; Useful for radio groups. link.props Converts the link to the standard { value, onChange } props to be easily consumed by standard &lt;input \/&gt; control. &lt;input type=&quot;text&quot; {...nameLink.props} \/&gt; link.action( ( prevValue, event ) =&gt; newValue ) Convert the link to the UI event handler event =&gt; void which will transform the link using the given function. link.action takes transform function, and produce a new function which takes single event argument. When it's called, event and link value are passes as transform parameters, and link will be updated with returned value. \/\/ simple click event handler... &lt;button onClick={ boolLink.action( x =&gt; !x ) } \/&gt; \/\/ manual binding to input control: const setValue = ( x, e ) =&gt; e.target.value; ... &lt;input value={ link.value } onChange={ link.action( setValue ) } \/&gt; This is particularly useful in (but not restricted to) UI event handlers. link.check( predicate : value =&gt; boolean, errorMsg? ) Checks whenever the predicate is truthy on linked value, and if it's not, assigns link.error with errorMsg. Does nothing if link.error is already populated. This method may be used for additional validation in render(), and to populate the validation error for the custom links created with Link.value(). You typically don't need link.check for links created with linkAt() methods, because the validation happens inside of records.","tags":"","url":"Link\/Link_transformations.html"},{"title":"Links to objects and arrays","text":"It's rather unusual scenario that you hold complex raw JS data as a part of your state, because typically the state is defined as a superposition of nested records and collections. Links can be used to make purely functional updates of the objects and arrays in records attributes. It's done with the help of at-links, which points to the elements of linked objects and arrays. Object and arrays methods link.at( key ) Create an at-link to the member of array or object. Whenever an at-link is updated, it will lead to proper purely functional update (with shallow copying) of the container (array or object). \/\/ Update this.state.array[ 0 ].name this.linkAt( 'array' ).at( 0 ).at( 'name' ).set( 'Joe' ); link.map( ( itemLink, itemKey ) =&gt; any | void ) Map and filter through the linked array or object to produce an array. Mapping function receives at-link to the corresponding element. Whenever it returns undefined, the corresponding element is be skipped. \/\/ Render the linked array... var list = stringArrayLink.map( ( itemLink, index ) =&gt; { if( itemLink.value ){ \/\/ Skip empty elements return ( &lt;div key={ index }&gt; &lt;Input valueLink={ itemLink } \/&gt; &lt;\/div&gt; ); } }); link.update( clonedObject =&gt; modifiedObject ) Update linked object or array. Plain objects and arrays are shallow copied already, thus it's safe just to update the value in place. \/\/ Update the linked object &lt;button onClick={ () =&gt; objLink.update( obj =&gt; { obj.a = 1; return obj; }) } \/&gt; link.action( ( clonedObject, event ) =&gt; Object ) Creates action to update enclosed object or array. Plain objects and arrays are shallow copied already, thus it's safe just to update the value in place. link.removeAt( key ) Remove element with a given key from the linked object or array. atLink.remove() Remove element with a given key from the linked object or array. Object-specific methods link.pick( key1, key2, ... ) Create at-links to the object's members with designated keys, and wrap them in an object. \/\/ Bulk create at-links for the linked object const { name, email } = objLink.pick( 'name', 'email' ); Array-specific methods linkToArray.splice() : void Similar to Array.splice() method, but performs purely functional update. linkToArray.push() : void Similar to Array.push() method, but performs purely functional update. linkToArray.unshift() : void Similar to Array.unshift() method, but performs purely functional update. linkToArray.contains( element ) Creates the boolean link to the presence of value in array. Resulting link value is true whenever element is present in array, and false otherwise. Whenever resulting link is assigned with new value, it will flip element in the array. Useful for the large checkbox groups.","tags":"","url":"Link\/Links_to_objects_and_arrays.html"},{"title":"Data-bound controls","text":"Ad-hoc data binding &lt;tag { ...link.props } \/&gt; Bind the linked value to any standard UI control expecting value and onChange props. Text controls Bind input or textarea to the linked string: \/\/ String &lt;input type=&quot;text&quot; {...link.props} \/&gt; &lt;textarea {...link.props} \/&gt; Checkboxes Bind the checkbox to the linked boolean: &lt;input type=&quot;checkbox&quot; {...boolLink.props } \/&gt; Bind the checkbox to the presence of value in the array: \/\/ array = [ 'optionA' ] &lt;input type=&quot;checkbox&quot; {...arrayLink.contains( 'optionA' ).props } \/&gt; \/\/ Checked &lt;input type=&quot;checkbox&quot; {...arrayLink.contains( 'optionB' ).props } \/&gt; \/\/ Unchecked Bind the checkbox to the presence of the record in the collection: &lt;input type=&quot;checkbox&quot; {...collection.linkContains( record ).props } \/&gt; Radio groups Bind radio group to the single linked value: \/\/ Radio &lt;input type=&quot;radio&quot; {...link.equals( 'optionA' ).props } \/&gt; &lt;input type=&quot;radio&quot; {...link.equals( 'optionB' ).props } \/&gt; Select list Bind select list to the linked value: \/\/ Select &lt;select {...link.props}&gt; &lt;option value=&quot;optionA&quot;&gt; A &lt;\/option&gt; &lt;option value=&quot;optionB&quot;&gt; B &lt;\/option&gt; &lt;\/select&gt; Linked UI controls Linked control is the custom React component taking the link property instead of value\/onChange props pair. It uses the link to extract the value and validation error, and to modify the value. Linked controls makes it possible to create the semantic form markup encapsulating inline validation and form layout styling. Not just form controls, but the most of the UI can benefit of this technique. \/\/ Custom data-bound control const Input = ({ link, ...props }) =&gt; ( &lt;div className={`form-row ${ link.error ? 'has-error' : '' } `}&gt; &lt;input type=&quot;text&quot; {...props} { ...link.props } \/&gt; &lt;div className=&quot;error-placeholder&quot;&gt;{ link.error || '' } &lt;\/div&gt; &lt;\/div&gt; ); \/\/ Another simple data bound control const Input = ({ link, ...props }) =&gt; ( &lt;input {...props} value={ link.value } onChange={ e =&gt; link.set( e.target.value ) } \/&gt; ); There are the set of pre-defined linked UI controls in react-mvx\/tags modules. Inline error indication is rather project-dependent, thus this file is intended to be used as a reference and starting boilerplate for your controls. import { Input } from 'react-mvx\/tags' Text input controls tags.jsx contains wrappers for standard &lt;input&gt; and &lt;textarea&gt; tags, which consume linked strings. These wrappers add invalid class to enclosed HTML element if an error is present in the link, and required class if isRequired validator is the failing one. import { Input, TextArea } from 'react-mvx\/tags' ... &lt;Input type=&quot;text&quot; valueLink={ link } \/&gt; &lt;TextArea valueLink={ link } \/&gt; Its implementation is rather straightforward. Numeric input In some cases you can use the wrong input rejection instead of (or in addition to) the validation. The most popular example is the numeric-only input control. It guarantees that the linked value will only be updated with the valid number, completely encapsulating all related checks and mechanics. The challenge here is that when number in not an integer it has to go through the sequence of intermediate invalid states during the editing process. Like &quot;&quot; -&gt; &quot;-&quot; -&gt; &quot;-0&quot; -&gt; &quot;-0.&quot; -&gt; &quot;-0.5&quot;. The proper implementation of wrong input rejection might be tough. tags.jsx contains the cross-browser numeric input tag. It has following differences compared to the regular &lt;Input&gt;: Keyboard input which obviously leads to invalid values (e.g. letters) is rejected. Link value is guaranteed to be the valid number. There are integer and positive boolean props controlling input rejection. They can be combined. &lt;NumberInput&gt; validates its intermediate state and adds invalid class to enclosed input element if it's not a number. import { NumberInput } from 'react-mvx\/tags' &lt;NumberInput valueLink={ link } \/&gt; &lt;NumberInput valueLink={ link } integer={ true }\/&gt; &lt;NumberInput valueLink={ link } positive={ true }\/&gt; Checkboxes There are different ways how you can handle the checkbox components. The problem of the standard checkbox control, though, is that it's not that easily styled. tags.jsx contains the custom checkbox and radio components implemented using the plain &lt;div \/&gt; element which toggles selected class on click. By default, it has checkbox CSS class, which can be overridden by passing className prop. It passes through anything else, including children. &lt;Checkbox checkedLink={ booleanLink } \/&gt; &lt;Checkbox checkedLink={ arrayLink.contains( 'option' ) } \/&gt; Radio Groups There are two different ways how you can approach the data binding for the radio groups. First option is to pass the value of the particular option along with the link. Link this: &lt;label&gt; A: &lt;Input type=&quot;radio&quot; valueLink={ flagLink } value=&quot;a&quot; \/&gt; &lt;\/label&gt; &lt;label&gt; B: &lt;Input type=&quot;radio&quot; valueLink={ flagLink } value=&quot;b&quot; \/&gt; &lt;\/label&gt; Alternatively, you can use link.equals( value ) method to produce the boolean link which is specially designed to create radio groups, as it's illustrated by the custom &lt;Radio \/&gt; tags from the tags.jsx. Internally, it's &lt;div&gt; element which always sets its link to true on click. And whenever the link value is true, it adds selected class to the div. By default, it has radio CSS class, which can be overridden by passing className prop. It passes through anything else, including children. &lt;label&gt; A: &lt;Radio checkedLink={ flagLink.equals( 'a' ) } \/&gt; &lt;\/label&gt; &lt;label&gt; B: &lt;Radio checkedLink={ flagLink.equals( 'b' ) } \/&gt; &lt;\/label&gt;","tags":"","url":"Data-bound_controls.html"},{"title":"Examples","text":"","tags":"","url":"Examples.html"}]}