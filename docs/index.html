<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta content="IE=edge,chrome=1" http-equiv="X-UA-Compatible">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <title>React-MVx 1.0 API Reference</title>

    <link rel="icon" href="images/logo-dark.png" />
    <link href="lib/stylesheets/screen.css" rel="stylesheet" type="text/css" media="screen" />
    <link href="lib/stylesheets/print.css" rel="stylesheet" type="text/css" media="print" />
    <link href="lib/stylesheets/default.css" rel="stylesheet" type="text/css" />

    <style>
      .logo-section img {
        vertical-align: middle;
        margin: 15px;
        height: 48px;
      }

      .logo-section .logo-text {
        vertical-align: middle;
        color: white;
        display: inline-block;
      }

      .logo-section .logo-caption {
        font-size: 28px;
      }

    </style>
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.0/jquery.min.js"></script>
      <script src="lib/javascripts/all.js" type="text/javascript"></script>

      <script>
        $(function() {
          var langs = [];
          setupLanguages( langs );
        });
      </script>
  </head>

  <body class="index">
    <a href="#" id="nav-button">
      <span>
        NAV
        <img src="images/navbar.png" />
      </span>
    </a>
    <div class="tocify-wrapper">
      <div class="logo-section">
        <img src="images/logo.png" />
        <div class="logo-text">
          <div class="logo-caption">React-TR 1.0</div>
          <div>MVVM architecture for React</div>
        </div>
        
      </div>
        <div class="lang-selector">
        </div>
        <div class="search">
          <input type="text" class="search" id="input-search" placeholder="Search">
        </div>
        <ul class="search-results"></ul>
      <div id="toc">
      </div>
        <ul class="toc-footer">
                <li><a href="https://github.com/Volicon/React-MVx">GitHub repository</a></li>
                <li><a href="https://github.com/Volicon/React-MVx/issues">Ask the question or report the bug</a></li>
                <li><a href="http://www.volicon.com/">Supported by <img style="vertical-align: middle" src="images/volicon_verizon_dm.png"/></a></li>
        </ul>
    </div>
    <div class="page-wrapper">
        <div class="content">
          <h1 id="getting-started">Getting started</h1>
<p>React-MVx is the MVVM SPA framework with React as View layer, which is built upon frontend technologies used at Volicon/Verizon for 3 years.</p>
<p>Contrary to the popular React approaches, React-MVx does not try to avoid the distributed mutable application state. Instead, it is focused on bringing stateful components capabilities to their maximum.</p>
<p>React-MVx manages both local UI state and application domain state with the same universal state container provided by <a href="https://volicon.github.com/Type-R">Type-R</a> data framework. It supports:</p>
<ul>
<li>two-way data binding</li>
<li>declarative state validation</li>
<li>nested data structures &amp; observable changes</li>
<li>painless state synchronization</li>
<li>automatic JSON serialization</li>
</ul>
<p>React-MVx application architecture follows scalable MVVM architecture pattern. It features the <em>unidirectional data flow</em> and <em>pure render</em> optimization. But contrary to the popular React state management solutions:</p>
<ul>
<li>It doesn&#39;t rely on singletons (unless you <em>really</em> need some data to be shared across pages)</li>
<li>It assists and encourages usage of <em>locally encapsulated state</em> and <em>OO decomposition</em>.</li>
</ul>
<h2 id="overview">Overview</h2>
<p>React-MVx is built around the idea of <em>universal state management</em> featuring 
the same technique to manage the local component state, application page state,
and the global application state.</p>
<p>Basic building blocks of the application architecture are:</p>
<ul>
<li>React-MVx Component (extended React.Component) for the view layer.</li>
<li>Records and Collection (provided by Type-R data framework) for managing all kinds of an application state.</li>
<li>Links for two-way data binding.</li>
<li>Stores (which is the subclass of the Record and can be dynamically created) for resolving record&#39;s id-references.</li>
</ul>
<p>React-MVx Component uses the Record class to manage its local state. Record can consists of other records 
and collections, describing the data structure of arbitrary complexity. All records are serializable by default, has deeply observable changes, and supports the declarative validation.</p>
<p>The behavior of record&#39;s attributes and component state/props elements is controlled with declarative <em>type annotations</em>. </p>
<p>React-MVx extends React namespace and should be used instead of <code>react</code>.
All class Component definitions must be preceeded with the <code>@define</code> decorator.</p>
<pre><code class="highlight javascript"><span class="hljs-keyword">import</span> React, { define } <span class="hljs-keyword">from</span> <span class="hljs-string">'react-mvx'</span>

@define class HelloApp extends React.Component {
    static state = {
        count : 0
    };

    render(){
        <span class="hljs-keyword">const</span> { state } = <span class="hljs-keyword">this</span>;
        <span class="hljs-keyword">return</span> (
            <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-title">h1</span> <span class="hljs-attribute">onClick</span>=<span class="hljs-value">{</span> () =&gt;</span> state.count++ }&gt;
                Hi there! { state.count }
            <span class="hljs-tag">&lt;/<span class="hljs-title">h1</span>&gt;</span>;</span>
        );
    }
}
</code></pre>
<h2 id="installation-requirements">Installation &amp; Requirements</h2>
<p>Supported browsers: Chrome, Firefox, Safari, IE10+.</p>
<p>Requires <code>react</code> and <code>type-r</code> as peer dependencies. Installation (assuming that React is installed):</p>
<pre><code><span class="hljs-string">`npm install react-mvx type-r --save-dev`</span>


</code></pre><p>TypeScript is unsupported (yet) but may work.</p>
<p>MIT License. Used and supported by Volicon and Verizon Digital Media Services.</p>

<h1 id="guide">Guide</h1>
<p>This guide is formed as series of short tutorials illustrating the most common programming patterns with React-MVx. Tutorials are built around <a href="https://github.com/gaperton/react-mvx-examples">React-MVx examples</a>.</p>
<h2 id="data-binding-and-forms">Data binding and forms</h2>
<p>In this tutorial we will learn the state management and two-way data binding basics on the example of the simple user info editing form.</p>
<p><img src="images/form.png" alt="form"></p>
<p>Our form will be the simple stateful component holding the state of the form in its local state, and for the purpose of the illustration storing its state in the browser&#39;s localStorage.</p>
<h3 id="defining-the-stateful-component">Defining the stateful component</h3>
<p>React-MVx extends React namespace and must be used instead of React. The most important class it exports is the modified <code>Component</code>.</p>
<p>The general definition of the stateful component looks like this:</p>
<pre><code class="highlight javascript"><span class="hljs-keyword">import</span> React, { define } <span class="hljs-keyword">from</span> <span class="hljs-string">'react-mvx'</span>
<span class="hljs-keyword">import</span> ReactDOM <span class="hljs-keyword">from</span> <span class="hljs-string">'react-dom'</span>

@define class Application extends React.Component {
    static state = {
        /* state attributes definition */
    };

    render(){
        <span class="hljs-keyword">return</span> (
            <span class="hljs-comment">/* jsx */</span>
        );
    }
}

ReactDOM.render( <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-title">Application</span>/&gt;</span>, document.getElementById( 'react-application' ) );</span>
</code></pre>
<p>There are few differences to raw React so far:</p>
<ul>
<li>Component definitions (as all React-MVx definitions) must be preceded with the <code>@define</code> decorator. </li>
<li>The state is not <em>assigned</em> in the constructor, but <em>declaratively defined</em> in class definition.</li>
</ul>
<h3 id="declaring-the-state">Declaring the state</h3>
<p>In the simplest case like ours when the state is flat and consists of primitive types, the state definition looks like the plain object. We list state attributes accompanied with their default values.</p>
<pre><code class="highlight javascript">    static state = {
        name : <span class="hljs-string">''</span>,
        email : <span class="hljs-string">''</span>,
        isActive : <span class="hljs-literal">true</span>
    };
</code></pre>
<p>This declaration will lead to an automatic creation of the observable <code>component.state</code> object of the similar shape when the <code>Application</code> component will be mounted. No need to initialize the state in the constructor.</p>
<p>No need for <code>component.setState()</code> either; plain assignments to the <code>component.state</code> members will be detected and will lead to the component&#39;s render. Which is cute, but we won&#39;t need any explicit state modifications in this example. Because we have two-way data binding.</p>
<h3 id="adding-the-form-s-markup">Adding the form&#39;s markup</h3>
<p>Now it&#39;s the time to create the markup for our form using the standard React&#39;s <a href="https://facebook.github.io/react/docs/forms.html#controlled-components">&quot;controlled components&quot;</a>. Controlled components do not have their own local state; it&#39;s mapped to some external state container.</p>
<p>In React-MVx this mapping is done with <em>links</em>. Think of <a href="../04_Link/00_Overview.md">link</a> in this example as an object-reference to the state&#39;s attribute. <code>link.props</code> return the <code>value</code>/<code>onChange</code> props pair which is expected by standard <em>controlled form components</em>.</p>
<pre><code class="highlight javascript">    render(){
        <span class="hljs-comment">// Link the state...</span>
        <span class="hljs-keyword">const</span> { name, email, isActive } = <span class="hljs-keyword">this</span>.linkAll();

        <span class="hljs-keyword">return</span> (
            <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-title">form</span>&gt;</span>
                <span class="hljs-tag">&lt;<span class="hljs-title">label</span>&gt;</span>
                    Name: <span class="hljs-tag">&lt;<span class="hljs-title">input</span> <span class="hljs-attribute">type</span>=<span class="hljs-value">"text"</span> { <span class="hljs-attribute">...name.props</span> }/&gt;</span>
                <span class="hljs-tag">&lt;/<span class="hljs-title">label</span>&gt;</span>

                <span class="hljs-tag">&lt;<span class="hljs-title">label</span>&gt;</span>
                    Email: <span class="hljs-tag">&lt;<span class="hljs-title">input</span> <span class="hljs-attribute">type</span>=<span class="hljs-value">"text"</span> { <span class="hljs-attribute">...email.props</span> }/&gt;</span>
                <span class="hljs-tag">&lt;/<span class="hljs-title">label</span>&gt;</span>

                <span class="hljs-tag">&lt;<span class="hljs-title">label</span>&gt;</span>
                    Is active: <span class="hljs-tag">&lt;<span class="hljs-title">input</span> <span class="hljs-attribute">type</span>=<span class="hljs-value">"checkbox"</span> { <span class="hljs-attribute">...isActive.props</span> }/&gt;</span>
                <span class="hljs-tag">&lt;/<span class="hljs-title">label</span>&gt;</span>
            <span class="hljs-tag">&lt;/<span class="hljs-title">form</span>&gt;</span>
        )</span>;
    }
</code></pre>
<p>At this stage, we have an editable form.</p>
<h3 id="adding-the-persistent-state">Adding the persistent state</h3>
<p>We would like to store the state of our form in the browser&#39;s localStorage. &quot;Save&quot; button must save the state, while &quot;Cancel&quot; must return the form to its default state. First of all, lets add these buttons:</p>
<pre><code class="highlight javascript">    render(){
        ...
        <span class="hljs-keyword">return</span> (
            <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-title">form</span> <span class="hljs-attribute">onSubmit</span>=<span class="hljs-value">{</span> <span class="hljs-attribute">this.onSubmit</span> }&gt;</span>
                ...
                <span class="hljs-tag">&lt;<span class="hljs-title">button</span> <span class="hljs-attribute">type</span>=<span class="hljs-value">"submit"</span>&gt;</span>Save<span class="hljs-tag">&lt;/<span class="hljs-title">button</span>&gt;</span>
                <span class="hljs-tag">&lt;<span class="hljs-title">button</span> <span class="hljs-attribute">type</span>=<span class="hljs-value">"button"</span> <span class="hljs-attribute">onClick</span>=<span class="hljs-value">{</span> <span class="hljs-attribute">this.onCancel</span> }&gt;</span>
                    Clear
                <span class="hljs-tag">&lt;/<span class="hljs-title">button</span>&gt;</span>
            <span class="hljs-tag">&lt;/<span class="hljs-title">form</span>&gt;</span>
        )</span>;
    }
</code></pre>
<p>We want &quot;Cancel&quot; button to set out state to its defaults, which is represented in the code quite literally:</p>
<pre><code class="highlight javascript">    onCancel = () =&gt; <span class="hljs-keyword">this</span>.state.set( <span class="hljs-keyword">this</span>.state.defaults() );
</code></pre>
<p>And the &quot;Save&quot; button must save the state to the localStorage. Good news is that <em>all the state in React-MVx is serializable by default</em>.</p>
<pre><code class="highlight javascript">    onSubmit = () =&gt; localStorage.setItem( <span class="hljs-string">'users-form'</span>, <span class="hljs-built_in">JSON</span>.stringify( <span class="hljs-keyword">this</span>.state ) );
</code></pre>
<p>Now, all we have to do is to restore the state on load. Which is done in the standard React&#39;s <code>componentWillMount</code> lifecycle hook.</p>
<pre><code class="highlight javascript">    componentWillMount(){
        <span class="hljs-keyword">const</span> json = <span class="hljs-built_in">JSON</span>.parse( localStorage.getItem( <span class="hljs-string">'users-form'</span> ) || <span class="hljs-string">'{}'</span> );
        <span class="hljs-keyword">this</span>.state.set( json, { parse : <span class="hljs-literal">true</span> } );
    }
</code></pre>
<p>That&#39;s really it. Here are the complete <a href="https://github.com/gaperton/react-mvx-examples/blob/master/src/form.jsx">sources</a> of our example, and here you can see the example <a href="https://gaperton.github.io/react-mvx-examples/dist/form.html">working</a>.</p>
<h3 id="api-used-in-the-example">API used in the example</h3>
<table>
<thead>
<tr>
<th>Name</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>static</code> state = { attrName : <code>attrDef</code>, ... }</td>
<td>Inline component state definition</td>
</tr>
<tr>
<td>component.state</td>
<td>record representing the component state</td>
</tr>
<tr>
<td>recordOrCollection.set( data, options? )</td>
<td>bulk update the record or collection</td>
</tr>
<tr>
<td>recordOrCollection.toJSON()</td>
<td>convert an object to JSON.</td>
</tr>
<tr>
<td>component.linkAll()</td>
<td>Create links to all state attributes. Same as <code>component.state.linkAll()</code></td>
</tr>
<tr>
<td>link.props</td>
<td>Convert the link to the standard pair of <code>value</code>/<code>onChange</code> props.</td>
</tr>
</tbody>
</table>
<h2 id="form-validation">Form Validation</h2>
<p>In this tutorial, we will add input validation to the user editing form from the <a href="01_Data_binding_and_forms.md">previous example</a>. That&#39;s the client-side &quot;as-you-type&quot; validation preventing the user from submitting invalid data while giving him hints.</p>
<p><img src="images/validation.png" alt="Validated form"></p>
<h3 id="state-definition-and-validation-checks">State definition and validation checks</h3>
<p>All state attributes in React-MVx has associated run-time types and the metadata. The general form of an attribute definition is <code>Constructor.value( defaultValue )</code>. When the <code>defaultValue</code> is used as an attribute definition (as it was in <a href="01_Data_binding_and_forms.md">previous example</a>), its type (Constructor) is taken from the value.</p>
<p><code>.value( defaultValue )</code> can be omitted as well. If an attribute definition is a function, it assumed to be the attribute&#39;s <code>Constructor</code>. Therefore, the following state definition is equivalent to one in the example.</p>
<pre><code class="highlight javascript">@define <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Application</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>{
    static state = {
        name : <span class="hljs-built_in">String</span>, <span class="hljs-comment">// same as ''</span>
        email : <span class="hljs-built_in">String</span>, <span class="hljs-comment">// same as ''</span>
        isActive : <span class="hljs-built_in">Boolean</span>.value( <span class="hljs-literal">true</span> ) <span class="hljs-comment">// same as true</span>
    };
    ...
}
</code></pre>
<p>This is important because validation checks are the part of the attribute definition. Which is cool, as it allows us to make custom attribute types with all of the validation checks encapsulated. Let&#39;s do this for the email.</p>
<p>Validator itself is the function taking the attribute&#39;s value and returning <code>true</code> whenever it is valid.</p>
<pre><code class="highlight javascript"><span class="hljs-comment">// Something simple, just for illustration purposes.</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isValidEmail</span>(<span class="hljs-params"> x </span>)</span>{
    <span class="hljs-keyword">return</span> !x || x.indexOf(<span class="hljs-string">'@'</span>) &gt;= <span class="hljs-number">0</span>;
}
</code></pre>
<p>Then, we need to attach the validator to the attribute definition. And we&#39;ve got the Email attribute type which can be used anywhere across the system.</p>
<pre><code class="highlight javascript"><span class="hljs-keyword">const</span> Email = <span class="hljs-built_in">String</span>.has.check( isValidEmail, <span class="hljs-string">'Invalid email'</span> );
</code></pre>
<p>Now we have all we need to define our state. We will use the built-in validation check <code>isRequired</code> which fails at empty values. This check is special because it is always executed first. Other <code>checks()</code> predicates can be chained and are executed in sequence.</p>
<pre><code class="highlight javascript">@define <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Application</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>{
    static state = {
        name : <span class="hljs-built_in">String</span>.isRequired,
        email : Email.isRequired,
        isActive : <span class="hljs-literal">true</span>
    };
    ...
}
</code></pre>
<h3 id="displaying-validation-errors">Displaying validation errors</h3>
<p>In React-MVx, the validation happens transparently and automatically. When you create the link, the attribute&#39;s validation error is accessible as <code>link.error</code>. Nothing special needs to be done to <em>trigger</em> the validation, all you have to do is to display the error.</p>
<pre><code class="highlight javascript">    render(){
        <span class="hljs-keyword">const</span> { name, email, isActive } = <span class="hljs-keyword">this</span>.linkAll();
        <span class="hljs-keyword">return</span> (
            <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-title">form</span> <span class="hljs-attribute">onSubmit</span>=<span class="hljs-value">{</span> <span class="hljs-attribute">this.onSubmit</span> }&gt;</span>
                <span class="hljs-tag">&lt;<span class="hljs-title">label</span>&gt;</span> Name: 
                    <span class="hljs-tag">&lt;<span class="hljs-title">div</span> <span class="hljs-attribute">className</span>=<span class="hljs-value">"validated-control"</span>&gt;</span>
                        <span class="hljs-tag">&lt;<span class="hljs-title">input</span> <span class="hljs-attribute">type</span>=<span class="hljs-value">"text"</span> { <span class="hljs-attribute">...name.props</span>} /&gt;</span>
                        { name.error &amp;&amp; <span class="hljs-tag">&lt;<span class="hljs-title">div</span> <span class="hljs-attribute">className</span>=<span class="hljs-value">"error"</span>&gt;</span>{ name.error }<span class="hljs-tag">&lt;/<span class="hljs-title">div</span>&gt;</span> }
                    <span class="hljs-tag">&lt;/<span class="hljs-title">div</span>&gt;</span>
                <span class="hljs-tag">&lt;/<span class="hljs-title">label</span>&gt;</span>
                ...
            <span class="hljs-tag">&lt;/<span class="hljs-title">form</span>&gt;</span>
        )</span>;
    }
</code></pre>
<p>And we would like to have the Save button disabled in case if the state is not valid for any reason:</p>
<pre><code class="highlight javascript">...
&lt;button type="submit" disabled={!this.state.isValid()}&gt;
    Save
&lt;/button&gt;
...
</code></pre>
<p>That&#39;s it. There&#39;s one more optional but important thing left to do, though.</p>
<h3 id="linked-ui-controls">Linked UI controls</h3>
<p>The final touch is to wrap the form&#39;s input displaying the validation error to the dedicated control, taking the <code>link</code> as an argument.</p>
<p>We define our own reusable <code>Input</code> form element which displays the validation error in the way we want:</p>
<pre><code class="highlight javascript"><span class="hljs-keyword">const</span> Input = ({ link, ...props }) =&gt; (
    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-title">div</span> <span class="hljs-attribute">className</span>=<span class="hljs-value">"validated-control"</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-title">input</span> {<span class="hljs-attribute">...props</span>} {<span class="hljs-attribute">...link.props</span>} /&gt;</span>
        { link.error &amp;&amp; <span class="hljs-tag">&lt;<span class="hljs-title">div</span> <span class="hljs-attribute">className</span>=<span class="hljs-value">"error"</span>&gt;</span>{ link.error }<span class="hljs-tag">&lt;/<span class="hljs-title">div</span>&gt;</span> }
    <span class="hljs-tag">&lt;/<span class="hljs-title">div</span>&gt;</span>
)</span>;
</code></pre>
<p>With that change, our <code>render()</code> method starts looking like this:</p>
<pre><code class="highlight javascript">render(){
    <span class="hljs-comment">// Link the state...</span>
    <span class="hljs-keyword">const</span> { name, email, isActive } = <span class="hljs-keyword">this</span>.linkAll();
    <span class="hljs-keyword">return</span> (
        <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-title">form</span> <span class="hljs-attribute">onSubmit</span>=<span class="hljs-value">{</span> <span class="hljs-attribute">this.onSubmit</span> }&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-title">label</span>&gt;</span>
                Name: <span class="hljs-tag">&lt;<span class="hljs-title">Input</span> <span class="hljs-attribute">type</span>=<span class="hljs-value">"text"</span> <span class="hljs-attribute">link</span>=<span class="hljs-value">{name}</span>/&gt;</span>
            <span class="hljs-tag">&lt;/<span class="hljs-title">label</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-title">label</span>&gt;</span>
                Email: <span class="hljs-tag">&lt;<span class="hljs-title">Input</span> <span class="hljs-attribute">type</span>=<span class="hljs-value">"text"</span> <span class="hljs-attribute">link</span>=<span class="hljs-value">{email}</span>/&gt;</span>
            <span class="hljs-tag">&lt;/<span class="hljs-title">label</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-title">label</span>&gt;</span>
                Is active: <span class="hljs-tag">&lt;<span class="hljs-title">input</span> <span class="hljs-attribute">type</span>=<span class="hljs-value">"checkbox"</span> {<span class="hljs-attribute">...isActive.props</span>}/&gt;</span>
            <span class="hljs-tag">&lt;/<span class="hljs-title">label</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-title">button</span> <span class="hljs-attribute">type</span>=<span class="hljs-value">"submit"</span> <span class="hljs-attribute">disabled</span>=<span class="hljs-value">{!this.state.isValid()}</span>&gt;</span>
                Save
            <span class="hljs-tag">&lt;/<span class="hljs-title">button</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-title">button</span> <span class="hljs-attribute">type</span>=<span class="hljs-value">"button"</span> <span class="hljs-attribute">onClick</span>=<span class="hljs-value">{this.onCancel}</span>&gt;</span>
                Clear
            <span class="hljs-tag">&lt;/<span class="hljs-title">button</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-title">form</span>&gt;</span>
    )</span>;
}
</code></pre>
<p>As you can see, the validation does not affect the markup in React-MVx. Thanks to the <em>links</em>, which conveniently transport the validation error from the place where it occurs to the place where it&#39;s consumed.</p>
<p>Here are the complete <a href="https://github.com/gaperton/react-mvx-examples/blob/master/src/validation.jsx">sources</a>, and here you can see the example <a href="https://gaperton.github.io/react-mvx-examples/dist/validation.html">working</a>.</p>
<h3 id="api-used-in-the-example">API used in the example</h3>
<table>
<thead>
<tr>
<th>Name</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>attrDef</code> : Type.value( defaultValue )</td>
<td>The general form of attribute definition where the <code>Type</code> is the constructor function.</td>
</tr>
<tr>
<td><code>attrDef</code> : Type</td>
<td>Attribute with a given type and the default value <code>new Type()</code> or <code>Type()</code> for primitives.</td>
</tr>
<tr>
<td><code>attrDef</code> : defaultValue</td>
<td>Attribute with the given default value and the type inferred from the value.</td>
</tr>
<tr>
<td><code>attrDef</code> : Type.has.check( predicate, errorMsg? )</td>
<td>Attribute-level validator.</td>
</tr>
<tr>
<td><code>attrDef</code> : Type.isRequired</td>
<td>The special case of attribute-level check cutting out empty values.</td>
</tr>
<tr>
<td>record.isValid()</td>
<td>Returns <code>true</code> whenever an object and its aggregation tree is valid.</td>
</tr>
</tbody>
</table>
<h2 id="managing-selection-in-lists">Managing selection in lists</h2>
<p>State of the lists is represented with Type-R&#39;s <code>Collection</code> type. Every <code>Record</code> class has the automatically created collection constructor which is referenced with <code>Record.Collection</code>.</p>
<h3 id="single-item-selection">Single item selection</h3>
<p>For the purpose of clarity we split the example into two components. Top-level holding the state, and the stateless component which will render the list.</p>
<pre><code class="highlight javascript">@define <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TopComponent</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>{
    static attributes = {
        items : User.Collection, <span class="hljs-comment">// aggregated collection of users</span>
        selected : User.shared <span class="hljs-comment">// reference to the record of this.users</span>
    };

    render(){
        <span class="hljs-keyword">const</span> { state } = <span class="hljs-keyword">this</span>;
        <span class="hljs-comment">// List must change the selection, thus it is passed as link.</span>
        <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-title">List</span> <span class="hljs-attribute">items</span>=<span class="hljs-value">{</span> <span class="hljs-attribute">state.items</span> }
                     <span class="hljs-attribute">selectedLink</span>=<span class="hljs-value">{</span> <span class="hljs-attribute">state.linkAt</span>( '<span class="hljs-attribute">selected</span>' ) } /&gt;</span>;</span>
    }
}
</code></pre>
<p>In Type-R, all the state is represented as the set of <em>aggregation trees</em>. By default, each nested record or collection is <em>aggregated</em> and behave as an integral part of the owner. It means, that it&#39;s created, copied, serialized, and validated recursively when it happens to its owner. And aggregation implies that there must be just the single owner, which is fine when the state has the proper tree structure.</p>
<p>Here, however, the state is not the tree. <code>selected</code> points to the elements of <code>items</code> collection, which would cause an aggregation error if we wouldn&#39;t marked is as <code>User.shared</code>. Now Type-R knows that <code>selected</code> is not an aggregation, but an association. Thus it can properly clone and dispose the state.</p>
<p><img src="images/selected-state.png" alt="selected state"></p>
<p>Our list component will be pure. Since it has to modify the selection on item&#39;s click, it needs to take the link to the selected element rather than the value.</p>
<pre><code class="highlight jsx">const List = ({ items, selectedLink }) =&gt; (
    <span class="hljs-tag">&lt;<span class="hljs-title">div</span> <span class="hljs-attribute">className</span>=<span class="hljs-value">"list"</span>&gt;</span>
        { items.map( item =&gt; (
            <span class="hljs-tag">&lt;<span class="hljs-title">div</span> <span class="hljs-attribute">key</span>=<span class="hljs-value">{</span> <span class="hljs-attribute">item.cid</span> }
                 <span class="hljs-attribute">className</span>=<span class="hljs-value">{</span> <span class="hljs-attribute">item</span> =<span class="hljs-value">==</span> <span class="hljs-attribute">selectedLink.value</span> ? '<span class="hljs-attribute">selected</span>' <span class="hljs-attribute">:</span> '' }
                 <span class="hljs-attribute">onClick</span>=<span class="hljs-value">{</span> () =&gt;</span> selectedLink.set( item ) }&gt;
                { item.name }
            <span class="hljs-tag">&lt;/<span class="hljs-title">div</span>&gt;</span>
        )}
    <span class="hljs-tag">&lt;/<span class="hljs-title">div</span>&gt;</span>
);
</code></pre>
<p>Every object in Type-R has <code>cid</code>. It&#39;s the unique client-only id generated upon object&#39;s creation. We used it here as <code>key</code> prop inside of map, so the React can handle items removal and insertions properly.</p>
<h3 id="multiple-items-selection">Multiple items selection</h3>
<p>The state of multi-selection is represented with the collection, but we can&#39;t just use <code>User.Collection</code> because the state will aggregate selected items twice. <code>Collection.Refs</code> is the type of the collection which does not aggregate its members.</p>
<pre><code class="highlight javascript">@define <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TopComponent</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>{
    static attributes = {
        items : User.Collection,
        selected : User.Collection.Refs 
    };

    render(){
        <span class="hljs-keyword">const</span> { state } = <span class="hljs-keyword">this</span>;
        <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-title">List</span> <span class="hljs-attribute">items</span>=<span class="hljs-value">{</span> <span class="hljs-attribute">state.items</span> }
                     <span class="hljs-attribute">selected</span>=<span class="hljs-value">{</span> <span class="hljs-attribute">state.selected</span> } /&gt;</span>;</span>
    }
}
</code></pre>
<p><code>Collection.Refs</code> is <em>non-aggregating collection</em>, which doesn&#39;t attempt to take an ownership on its elements. Whenever the state will be cloned <code>selected</code> collection itself will be shallow cloned, while the <code>items</code> collection will be deeply cloned.</p>
<p><img src="images/multiselect-state.png" alt="multiselect state"></p>
<p>In Type-R, the nested records and collections are mutable and deeply observable. <code>state.selected</code> is an object, so we can just pass it to the List component as it is. Whenever it will be updated, the change will be noticed by the TopComponent which will cause the render.</p>
<pre><code class="highlight javascript">const List = ({ items, selected }) =&gt; (
    &lt;div className="list"&gt;
        { items.map( item =&gt; (
            &lt;div key={ item.cid }
                 className={ selected.get( item ) ? 'selected' : '' }
                 onClick={ () =&gt; selected.toggle( item ) }&gt;
                { item.name }
            &lt;/div&gt;
        )}
    &lt;/div&gt;
);
</code></pre>
<h3 id="making-the-state-serializable">Making the state serializable</h3>
<p><code>User.shared</code> and <code>Collection.Refs</code> are not present in JSON
when the <code>state.toJSON()</code> is called. They are <em>non-serializable</em> references, and it&#39;s &#39;s okay for the UI state in the majority of cases.</p>
<p>You need to use <code>Record.from</code> and <code>Collection.subsetOf</code> attribute definitions to make the serializable. Both of them take the reference to the master collection which is used to restore elements from their ids. The reference is the dot-separated path to the collection taken relative to the record&#39;s <code>this</code>.</p>
<aside class="notice">
id-references notation is more informative to the reader and should be preferred to `shared` and `Refs` anywhere where it's possible.
</aside>

<pre><code class="highlight javascript">static attributes = {
    items : User.Collection,
    selected : User.from( <span class="hljs-string">'items'</span> ) <span class="hljs-comment">// as an id of the record from this.items collection in JSON</span>
};
</code></pre>
<pre><code class="highlight javascript">static attributes = {
    items : User.Collection,
    selected : User.Collection.subsetOf( <span class="hljs-string">'items'</span> ) <span class="hljs-comment">// as array of ids of records from this.items in JSON</span>
};
</code></pre>
<h3 id="api-used-in-the-example">API used in the example</h3>
<table>
<thead>
<tr>
<th>Name</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
</tr>
</tbody>
</table>
<h1 id="component">Component</h1>
<p>React-MVx extends React namespace and should be used instead of <code>react</code>.
All class Component definitions must be preceeded with the <code>@define</code> decorator.</p>
<p>All features of the Component are controlled through the unified property and attribute declarations.</p>
<pre><code class="highlight javascript"><span class="hljs-keyword">import</span> React, { define } <span class="hljs-keyword">from</span> <span class="hljs-string">'react-mvx'</span>

@define class Hello extends React.Component {
    static props = { // instead of `propTypes` and `defaultProps`
        propName : `propDef`,
        ...
    }

    static context = { // instead of `contextTypes`
        propName : `propDef`,
        ...
    }

    static childContext = { // instead of `childContextTypes`
        propName : `propDef`,
        ...
    }

    static state = { // instead of <span class="hljs-string">"this.state = "</span> in the constructor.
        attrName : `attrDef`,
        ...
    }

    static store = { // store
        attrName : `attrDef`,
        ...
    }

    render(){...}
}
</code></pre>
<h2 id="props-and-state-definitions">props and state definitions</h2>
<p>The majority of React-MVx features are controlled with declarative props, state, store, and context type annotations.</p>
<h3 id="everything-state-store-props-and-context-">Everything (state, store, props, and context)</h3>
<p>Type annotations below represents the run-time type assertions.</p>
<table>
<thead>
<tr>
<th>Annotation</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td><code>Ctor</code></td>
<td>element has specified type</td>
</tr>
<tr>
<td></td>
<td><code>Ctor.isRequired</code></td>
<td>element is required</td>
</tr>
<tr>
<td></td>
<td><code>Ctor.has.check(...)</code></td>
<td>custom validation check</td>
</tr>
</tbody>
</table>
<h3 id="state-store-and-props">state, store, and props</h3>
<p>You can specify the default value for an attribute or prop, and reactions on its change.</p>
<table>
<thead>
<tr>
<th>Annotation</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td><code>Ctor.value( defaultValue )</code></td>
<td>element has default value</td>
</tr>
<tr>
<td></td>
<td><code>defaultValue</code></td>
<td>element has default value</td>
</tr>
<tr>
<td></td>
<td><code>Ctor.has.watcher(...)</code></td>
<td>custom reaction on element&#39;s change </td>
</tr>
<tr>
<td></td>
<td><code>Ctor.has.events(...)</code></td>
<td>listen to custom events from the element</td>
</tr>
<tr>
<td></td>
<td><code>Ctor.has.changeEvents(...)</code></td>
<td>update on element&#39;s changes</td>
</tr>
</tbody>
</table>
<h3 id="state-and-store">state and store</h3>
<p>You have an an attribute-level control of the serialization and ownership for the state, store, and records attributes.</p>
<table>
<thead>
<tr>
<th>Annotation</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td><code>Record.shared</code></td>
<td>attribute holds the reference to the record</td>
<td></td>
</tr>
<tr>
<td></td>
<td><code>Collection.Refs</code></td>
<td>collection of references to the records</td>
<td></td>
</tr>
<tr>
<td></td>
<td><code>Record.from(...)</code></td>
<td>reference to the record from the specified collection</td>
<td></td>
</tr>
<tr>
<td></td>
<td><code>Collection.subsetOf(...)</code></td>
<td>collection of references to the records from the specified collection</td>
<td></td>
</tr>
<tr>
<td></td>
<td><code>Ctor.has.parse(...)</code></td>
<td>custom parse hook</td>
<td></td>
</tr>
<tr>
<td></td>
<td><code>Ctor.has.toJSON(...)</code></td>
<td>custom serialization hook</td>
<td></td>
</tr>
<tr>
<td></td>
<td><code>Ctor.has.get(...)</code></td>
<td>attribute read hook</td>
<td></td>
</tr>
<tr>
<td></td>
<td><code>Ctor.has.set(...)</code></td>
<td>attribute write hook</td>
<td></td>
</tr>
<tr>
<td></td>
<td><code>Ctor.has.metadata(...)</code></td>
<td>attach custom metadata to the attribute</td>
<td></td>
</tr>
</tbody>
</table>
<h2 id="props">props</h2>
<p>Component <em>static props declaration</em> replaces standard React&#39;s <code>propTypes</code> and <code>defaultProps</code>.</p>
<h3 id="-static-props-name-propdef-"><code>static</code> props = { name : <code>propDef</code>, ... }</h3>
<p>Declare component props. Declaration is an object </p>
<pre><code class="highlight javascript"><span class="hljs-keyword">import</span> React, { define } <span class="hljs-keyword">from</span> <span class="hljs-string">'react-mvx'</span>

@define class PropsDemo extends React.Component {
    static props = {
        name : Declaration,
        ...
    }
}
</code></pre>
<h3 id="-static-purerender-true"><code>static</code> pureRender = true</h3>
<p>Prevents subsequent render calls in case if props were unchanged. It&#39;s known as &quot;pure render&quot; optimization.</p>
<p><em>Inner changes of records and collections</em> are detected and taken into account. Thus, it works properly with mutable records and collections.</p>
<p><code>static props</code> declaration is required for <code>pureRender</code> to work. Only declared props will be tracked and compared.</p>
<h3 id="-propdef-name-constructor"><code>propDef</code> name : Constructor</h3>
<p>Checks if component prop is an instance of the <code>Constructor</code> and puts the warning to the console if the prop type is not compatible.</p>
<h3 id="-propdef-name-constructor-isrequired"><code>propDef</code> name : Constructor.isRequired</h3>
<p>Mark property as required.</p>
<pre><code class="highlight javascript">import React, { define } from &#39;react-mvx&#39;
@define class PropsDemo extends React.Component {
    static props = {
        // Simple form of annotation is just the constructor function designating the type.
        optionalArray: Array,
        optionalBool: Boolean,
        optionalFunc: Function,
        optionalNumber: Number,
        optionalObject: Object,
        optionalString: String,
        optionalSymbol: Symbol,   

        // Anything that can be rendered: numbers, strings, elements or an array
        // (or fragment) containing these types.
        optionalNode: React.Node,

        // A React element.
        optionalElement: React.Element,

        // You can also declare that a prop is an instance of a class.
        optionalMessage: Message,

        // You can chain any of the above with `isRequired` to make sure a warning
        // is shown if the prop isn&#39;t provided.
        requiredFunction : Function.isRequired
    };
    ...
}
</code></pre>
<h3 id="-propdef-name-constructor-value-defaultvalue-"><code>propDef</code> name : Constructor.value( defaultValue )</h3>
<p>Assign default property value.</p>
<h3 id="-propdef-name-defaultvalue"><code>propDef</code> name : defaultValue</h3>
<p>Assign default property value. The the type will be inferred from the <code>defaultValue</code>.</p>
<p>Any function in props annotation is treated as a constructor. Thus, <code>Function.value( defaultValue )</code> must be used to specify the defaults for functions.</p>
<pre><code class="highlight javascript"><span class="hljs-keyword">import</span> React, { define } <span class="hljs-keyword">from</span> <span class="hljs-string">'react-mvx'</span>

@define class PropsDemo extends React.Component {
    static props = {
        withDefault : String.value( <span class="hljs-string">'defaultValue'</span> ),
        anotherDefault : <span class="hljs-string">'defaultValue'</span>
    }
}
</code></pre>
<h3 id="-propdef-name-constructor-has-watcher-componentmethodname-"><code>propDef</code> name : Constructor.has.watcher( &#39;componentMethodName&#39; )</h3>
<h3 id="-propdef-name-constructor-has-watcher-function-newvalue-name-"><code>propDef</code> name : Constructor.has.watcher( function( newValue, name ){ ... } )</h3>
<p><em>Watcher</em> is the function which is called when the particular prop is assigned with new value.</p>
<p>Watcher is called after <code>componentWillMount</code>, and may be called during <code>componentWillReceiveProps</code> if the property is changed.
Watcher is executed in the context of the component.</p>
<pre><code class="highlight javascript"><span class="hljs-keyword">import</span> React, { define } <span class="hljs-keyword">from</span> <span class="hljs-string">'react-mvx'</span>

@define class PropsDemo extends React.Component {
    static props = {
        first : String.has.watcher( <span class="hljs-string">'onFirstChange'</span> ),
        second : Number.has.watcher( second =&gt; console.log( <span class="hljs-string">'Received new prop:'</span>, second ) )
    }

    onFirstChange( newValue, name ){
        console.log( <span class="hljs-string">'First prop is about to change:'</span>, newValue );
    }
}
</code></pre>
<h3 id="-propdef-name-recordorcollection-has-changeevents-true-"><code>propDef</code> name : RecordOrCollection.has.changeEvents( true )</h3>
<p>Observe <em>internal changes</em> of the record or collection and update the component in case of changes.</p>
<h3 id="-propdef-name-eventsource-has-changeevents-event1-event2-"><code>propDef</code> name : EventSource.has.changeEvents( &#39;event1 event2 ...&#39; )</h3>
<p>Update the component in case if property triggers any of the listed events.</p>
<pre><code class="highlight javascript"><span class="hljs-keyword">import</span> React, { define } <span class="hljs-keyword">from</span> <span class="hljs-string">'react-mvx'</span>
<span class="hljs-keyword">import</span> { Record } <span class="hljs-keyword">from</span> <span class="hljs-string">'react-mvx'</span>

@define class PropsDemo extends React.Component {
    static props = {
        // Render on every change
        trackInnerChanges : Record.has.changeEvents( true ),
        // Render when record is added to or removed <span class="hljs-keyword">from</span> the collection
        anotherDefault : Collection.has.changeEvents( <span class="hljs-string">'add remove'</span> )
    }
}
</code></pre>
<h3 id="-propdef-name-eventsource-has-events-event-handler-"><code>propDef</code> name : EventSource.has.events({ event : handler, ... })</h3>
<p>Subscribe for events from the component property. <code>handler</code> can either be the name of the component&#39;s method,
or the function handling the event. Handler is executed in the context of the component.</p>
<h2 id="state">state</h2>
<p>Component&#39;s state is modeled as Type-R <code>Record</code>. Record is created before <code>componentWillMount()</code> and disposed after <code>componentWillUnmount()</code>.
All changed inside of the state record are observed, and the component is updated in case of change.</p>
<h3 id="-static-state-recordconstructor"><code>static</code> state = RecordConstructor</h3>
<p>Define stateful component with the state Record declared externally.</p>
<h3 id="-static-state-name-attrdef-"><code>static</code> state = { name : <code>attrDef</code>, ... }</h3>
<p>Implicitly define state Record with a given attributes declaration. All declarations working on <code>props</code> works for the state as well. Refer to the Record documentation for the attributes declaration syntax.</p>
<h3 id="component-state">component.state</h3>
<p>Holds an object of the <code>Record</code> subclass. </p>
<p><em>Do not use <code>component.setState()</code></em>. Use direct assignments to modify the state:</p>
<pre><code><span class="hljs-keyword">this</span>.state.x = <span class="hljs-number">5</span>;


</code></pre><p>Refer to the Record documentation for the complete list of methods.</p>
<h3 id="component-transaction-fun-">component.transaction( fun )</h3>
<p>Group the sequence of state (and props) updates in the single transaction leading to single UI update.</p>
<pre><code><span class="hljs-keyword">this</span>.transaction( state =&gt; {
    state.a++;
    state.b++;
    <span class="hljs-keyword">this</span>.props.collection.reset();
});


</code></pre><p>Read more about transactions in Record&#39;s manual.</p>
<h2 id="store">store</h2>
<p>Stores in Type-R are internally similar to the Record and used to resolve one-to-many and many-to-many relationships by id.
Stores <em>must not</em> be used to store UI state; they are intended to hold the shared domain state which is cross-referenced by id.</p>
<p>There may be multiple stores in Rect-MVx. There is the single <em>default store</em> (<code>Store.global</code>) which is used to cache the data that must be accessible across the pages.</p>
<p>Specifying the store for the top-level component sets this store as the primary one for all the internal state of the current component subtree.</p>
<h3 id="-static-store-existingstore"><code>static</code> store = existingStore</h3>
<p>Expose the <code>existingStore</code> to the component subtree. Update component on store changes.</p>
<h3 id="-static-store-storeconstructor"><code>static</code> store = StoreConstructor</h3>
<p>Creates the local store on component&#39;s mount and dispose it when component is unmounted.</p>
<p>Expose the store to the component subtree. Update component on store changes.</p>
<h3 id="-static-store-attrname-attrdef-"><code>static</code> store = { attrName : <code>attrDef</code>, ... }</h3>
<p>Implicitly create the <code>Store</code> subclass from the given attribute spec.</p>
<p>Accepts the same <code>attrDef</code> as the <code>state</code> and <code>Record</code>.</p>
<h3 id="component-store">component.store</h3>
<p>When the <code>static store</code> is defined, provide the access to the store in component.</p>
<p>Store <em>is not</em> directly accessible to the subcomponents; you have to pass values down as props.</p>
<h2 id="context">context</h2>
<p>Static <code>context</code> and <code>childContext</code> declarations replaces React&#39;s standard <code>contextTypes</code> and <code>childContextTypes</code>.</p>
<h3 id="-static-context-name-propdef-"><code>static</code> context = { name : <code>propDef</code>, ... }</h3>
<p>Replacement for standard <code>contextTypes</code>.</p>
<h3 id="-static-childcontext-name-propdef-"><code>static</code> childContext = { name : <code>propDef</code>, ... }</h3>
<p>Replacement for standard <code>childContextTypes</code>.</p>
<p><code>getChildContext()</code> function is required to create the context as in raw React.</p>
<p>Subset of <code>static props</code> declaration is supported for the context <code>propDef</code>.</p>
<h3 id="-propdef-name-constructor"><code>propDef</code> name : Constructor</h3>
<p>Checks whenever the value is an instance of the <code>Constructor</code> and puts the warning to the console if the prop type is not compatible.</p>
<h3 id="-propdef-name-constructor-isrequired"><code>propDef</code> name : Constructor.isRequired</h3>
<p>Value is required.</p>
<h2 id="links-to-state">Links to state</h2>
<p>Component implements shorthand methods for creating links to state.
The same API is implemented by every Record class. All the methods below generally forward calls to the <code>component.state</code>.</p>
<h3 id="component-linkat-key-">component.linkAt( &#39;key&#39; )</h3>
<p>Create the link for the state member <code>key</code>. Is a shortcut for <code>component.state.linkAt()</code> method.</p>
<p>All records support <code>linkAt()</code> method as well.</p>
<h3 id="component-linkall-">component.linkAll()</h3>
<p>Create links for all (or specified) the state members. All records support <code>linkAll()</code> method as well.</p>
<h3 id="component-links">component.links</h3>
<p>Direct access to the links cache. Can be used in event handlers to access the links created during the last <code>render()</code>.</p>
<p>All links created for records (and for the component&#39;s state) are being cached. They are recreated only in case when their value has been changed.</p>
<h2 id="ui-updates">UI updates</h2>
<h3 id="component-asyncupdate-">component.asyncUpdate()</h3>
<p>Safe version of the <code>forceUpdate()</code>. Gracefully handles component disposal and UI update transactions.</p>
<p>Shall be used in place of every manual call to <code>forceUpdate()</code>.</p>
<h2 id="events">Events</h2>
<p>Component implements <code>Events</code> interface from the Type-R framework, thus it&#39;s able to trigger and subscribe for events.</p>
<h1 id="link">Link</h1>
<p>Link is an intermediate object used to implement the two-way data binding.
It acts like a transport for the value, the callback to modify it, its validation error, abstracting out
UI controls from the data representation in the state container and from the state container per se.</p>
<p>Links to the record&#39;s attributes are commonly created with <code>linkAt</code> and <code>linkAll</code> methods of records.
Record is automatically validated upon the links creation, and link encloses the validation error
related to the particuler attribute.</p>
<pre><code class="highlight javascript"><span class="hljs-comment">// Data bound control for the semantic form markup</span>
<span class="hljs-keyword">const</span> Input = ({ valueLink, ...props }) =&gt; (
    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-title">div</span> <span class="hljs-attribute">className</span>=<span class="hljs-value">{`form-control</span> ${ <span class="hljs-attribute">valueLink.error</span> ? '<span class="hljs-attribute">error</span>' <span class="hljs-attribute">:</span> '' }`}&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-title">input</span> {<span class="hljs-attribute">...props</span>}
            <span class="hljs-attribute">value</span>=<span class="hljs-value">{</span> <span class="hljs-attribute">valueLink.value</span> }
            <span class="hljs-attribute">onChange</span>=<span class="hljs-value">{</span> <span class="hljs-attribute">e</span> =&gt;</span> valueLink.set( e.target.value ) }
        /&gt;
        <span class="hljs-tag">&lt;<span class="hljs-title">div</span> <span class="hljs-attribute">className</span>=<span class="hljs-value">"validation-error"</span>&gt;</span>{ valueLink.error || '' }<span class="hljs-tag">&lt;/<span class="hljs-title">div</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-title">div</span>&gt;</span>
)</span>;
</code></pre>
<p>Links makes it possible to create the semantic markup for the form elements, encapsulating the
all the required styles and validation error indication.</p>
<h2 id="link-structure">Link structure</h2>
<p>Here are the most important link members. All the link members are read-only and should not be modified directly.</p>
<pre><code class="highlight javascript"><span class="hljs-comment">// Link's shape</span>
{
    value : <span class="hljs-comment">/* the value */</span>,
    set( newValue ){ <span class="hljs-comment">/* the function to change it */</span>},
    error : <span class="hljs-comment">/* validation error */</span>
}
</code></pre>
<h3 id="link-value">link.value</h3>
<p>Holds linked value. This value is immutable.</p>
<h3 id="link-error">link.error</h3>
<p>Holds the validation error (typically the text error message) which might be consumed and displayed by data-bound countrol.</p>
<p>An <code>error</code> is populated automatically on link creation when using <code>linkAt()</code> or <code>linkAll()</code> methods, and is produced by declarative
validators from <code>.has.check()</code> attributes annotations.</p>
<h3 id="link-set-newvalue-">link.set( newValue )</h3>
<p>Tells the state container to update the value.</p>
<pre><code class="highlight javascript">&lt;button onClick={ () =&gt; boolLink.set( !boolLink.value ) } /&gt;
</code></pre>
<h3 id="link-update-prevvalue-newvalue-">link.update( prevValue =&gt; newValue )</h3>
<p>Update link value using the given value transform function.</p>
<pre><code class="highlight javascript">&lt;button onClick={ () =&gt; boolLink.update( x =&gt; !x ) } /&gt;
</code></pre>
<h2 id="create">Create</h2>
<p>All records and collections may create links to its elements.
Component has the shorthand methods to create links to its state record elements.</p>
<p>You can create custom link object encapsulating complex data binding logic with <code>Link.value</code>.</p>
<h3 id="record-linkat-attr-">record.linkAt( attr )</h3>
<p>Create the link to the record&#39;s attribute. Semantically it&#39;s the reference to the attribute.</p>
<pre><code class="highlight javascript"><span class="hljs-keyword">const</span> nameLink = user.linkAt( <span class="hljs-string">'name'</span> );
</code></pre>
<h3 id="collection-linkat-prop-">collection.linkAt( prop )</h3>
<p>Create the link to the custom collection property. Property&#39;s setter <em>must</em> modify some record&#39;s attributes or change the collection.</p>
<h3 id="component-linkat-key-">component.linkAt( key )</h3>
<p>Create the link to the attribute of the conponent&#39;s state. Works similar to <code>component.state.linkAt( key )</code>.</p>
<h3 id="record-linkall-">record.linkAll()</h3>
<p>Link all (or listed) records&#39; attributes.</p>
<pre><code class="highlight javascript"><span class="hljs-comment">// Link all attributes...</span>
<span class="hljs-keyword">const</span> { name, email, age } = user.linkAll();

<span class="hljs-comment">// Link specified attributes...</span>
<span class="hljs-keyword">const</span> { name, email } = user.linkAll( <span class="hljs-string">'name'</span>, <span class="hljs-string">'email'</span> );
</code></pre>
<h3 id="component-linkall-">component.linkAll()</h3>
<p>Link all (or listed) attributes of the component&#39;s state. Works similar to <code>component.state.linkAll()</code>.</p>
<h3 id="collection-linkcontains-record-">collection.linkContains( record )</h3>
<p>Create the boolean link which is <code>true</code> whenever the record is contained in the collection.</p>
<p>Setting the link to <code>false</code> will remove record from the collection, setting it to true will add it.</p>
<h3 id="link-value-value-set-">Link.value( value, set )</h3>
<p>Create custom link with the given <code>value</code> and <code>set</code> function. Use the <code>link.check</code> method to populate the validation error.</p>
<h2 id="transform">Transform</h2>
<h3 id="link-equals-value-">link.equals( value )</h3>
<p>Create boolean equality link which value is <code>true</code> whenever <code>link.value === value</code>, and <code>false</code> otherwise.</p>
<p>When an equality link is assigned with <code>true</code> the parent link value is set with <code>value</code>, and with <code>null</code> otherwise.</p>
<pre><code class="highlight javascript">&lt;Checkbox checkedLink={ stringLink.equals( <span class="hljs-string">'optionX'</span> ) } /&gt;
<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-title">Checkbox</span> <span class="hljs-attribute">checkedLink</span>=<span class="hljs-value">{</span> <span class="hljs-attribute">stringLink.equals</span>( '<span class="hljs-attribute">optionY</span>' ) } /&gt;</span></span>
</code></pre>
<p>Useful for radio groups.</p>
<h3 id="link-props">link.props</h3>
<p>Converts the link to the standard <code>{ value, onChange }</code> props to be easily consumed by standard <code>&lt;input /&gt;</code> control.</p>
<pre><code class="highlight javascript">&lt;input type=<span class="hljs-string">"text"</span> {...nameLink.props} /&gt;
</code></pre>
<h3 id="link-action-prevvalue-event-newvalue-">link.action( ( prevValue, event ) =&gt; newValue )</h3>
<p>Convert the link to the UI event handler <code>event =&gt; void</code> which will transform the link using the given function.</p>
<p><code>link.action</code> takes transform function, and produce a new function which takes single <code>event</code> argument.
When it&#39;s called, <code>event</code> and link <code>value</code> are passes as transform parameters, and link will be updated 
with returned value.</p>
<pre><code class="highlight javascript"><span class="hljs-comment">// simple click event handler...</span>
&lt;button onClick={ boolLink.action( x =&gt; !x ) } /&gt;

<span class="hljs-comment">// manual binding to input control:</span>
<span class="hljs-keyword">const</span> setValue = ( x, e ) =&gt; e.target.value;
...
&lt;input  value={ link.value }
        onChange={ link.action( setValue ) } /&gt;
</code></pre>
<p>This is particularly useful in (but not restricted to) UI event handlers.</p>
<h3 id="link-check-predicate-value-boolean-errormsg-">link.check( predicate : value =&gt; boolean, errorMsg? )</h3>
<p>Checks whenever the predicate is truthy on linked value, and if it&#39;s not, assigns <code>link.error</code> with <code>errorMsg</code>.
Does nothing if <code>link.error</code> is already populated.</p>
<p>This method may be used for additional validation in <code>render()</code>, and to populate the validation error for the custom links created with <code>Link.value()</code>.</p>
<p>You typically don&#39;t need <code>link.check</code> for links created with <code>linkAt()</code> methods, because the validation happens inside of records.</p>
<h2 id="link-to-objects-and-arrays">Link to objects and arrays</h2>
<p>It&#39;s rather unusual scenario that you hold complex raw JS data as a part of your state, because typically the state is
defined as a superposition of nested records and collections.</p>
<p>Links can be used to make purely functional updates of the objects and arrays in records attributes. It&#39;s done with
the help of <em>at-links</em>, which points to the elements of linked objects and arrays.</p>
<h3 id="link-at-key-">link.at( key )</h3>
<p>Create an <em>at-link</em> to the member of array or object.</p>
<p>Whenever an <em>at-link</em> is updated, it will lead to proper purely functional update (with shallow copying) of the
container (array or object).</p>
<pre><code class="highlight javascript"><span class="hljs-comment">// Update this.state.array[ 0 ].name</span>
<span class="hljs-keyword">this</span>.linkAt( <span class="hljs-string">'array'</span> ).at( <span class="hljs-number">0</span> ).at( <span class="hljs-string">'name'</span> ).set( <span class="hljs-string">'Joe'</span> );
</code></pre>
<h3 id="link-map-itemlink-itemkey-any-void-">link.map( ( itemLink, itemKey ) =&gt; any | void )</h3>
<p>Map and filter through the linked array or object to produce an array.
Mapping function receives <em>at-link</em> to the corresponding element.
Whenever it returns <code>undefined</code>, the corresponding element is be skipped.</p>
<pre><code class="highlight javascript"><span class="hljs-comment">// Render the linked array...</span>
<span class="hljs-keyword">var</span> list = stringArrayLink.map( ( itemLink, index ) =&gt; {
    <span class="hljs-keyword">if</span>( itemLink.value ){ <span class="hljs-comment">// Skip empty elements</span>
        <span class="hljs-keyword">return</span> (
            <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-title">div</span> <span class="hljs-attribute">key</span>=<span class="hljs-value">{</span> <span class="hljs-attribute">index</span> }&gt;</span>
                <span class="hljs-tag">&lt;<span class="hljs-title">Input</span> <span class="hljs-attribute">valueLink</span>=<span class="hljs-value">{</span> <span class="hljs-attribute">itemLink</span> } /&gt;</span>
            <span class="hljs-tag">&lt;/<span class="hljs-title">div</span>&gt;</span>
        )</span>;
    }
});
</code></pre>
<h3 id="link-update-clonedobject-modifiedobject-">link.update( clonedObject =&gt; modifiedObject )</h3>
<p>Update linked object or array.</p>
<p>Plain objects and arrays are shallow copied already, thus it&#39;s safe just to update the value in place.</p>
<pre><code class="highlight javascript"><span class="hljs-comment">// Update the linked object</span>
&lt;button onClick={ () =&gt; objLink.update( obj =&gt; {
                                obj.a = <span class="hljs-number">1</span>;
                                <span class="hljs-keyword">return</span> obj;
                            }) } /&gt;
</code></pre>
<h3 id="link-action-clonedobject-event-object-">link.action( ( clonedObject, event ) =&gt; Object )</h3>
<p>Creates action to update enclosed object or array.</p>
<p>Plain objects and arrays are shallow copied already, thus it&#39;s safe just to update the value in place.</p>
<h3 id="link-removeat-key-">link.removeAt( key )</h3>
<p>Remove element with a given key from the linked object or array.</p>
<h3 id="atlink-remove-">atLink.remove()</h3>
<p>Remove element with a given key from the linked object or array.</p>
<h2 id="link-to-objects">Link to objects</h2>
<h3 id="link-pick-key1-key2-">link.pick( key1, key2, ... )</h3>
<p>Create <em>at-links</em> to the object&#39;s members with designated keys, and wrap them in an object.</p>
<pre><code class="highlight javascript"><span class="hljs-comment">// Bulk create at-links for the linked object</span>
<span class="hljs-keyword">const</span> { name, email } = objLink.pick( <span class="hljs-string">'name'</span>, <span class="hljs-string">'email'</span> );
</code></pre>
<h2 id="link-to-arrays">Link to arrays</h2>
<h3 id="linktoarray-splice-void">linkToArray.splice() : void</h3>
<p>Similar to <code>Array.splice()</code> method, but performs purely functional update.</p>
<h3 id="linktoarray-push-void">linkToArray.push() : void</h3>
<p>Similar to <code>Array.push()</code> method, but performs purely functional update.</p>
<h3 id="linktoarray-unshift-void">linkToArray.unshift() : void</h3>
<p>Similar to <code>Array.unshift()</code> method, but performs purely functional update.</p>
<h3 id="linktoarray-contains-element-">linkToArray.contains( element )</h3>
<p>Creates the boolean link to the presence of value in array.</p>
<p>Resulting link value is <code>true</code> whenever element is present in array, and <code>false</code> otherwise.
Whenever resulting link is assigned with new value, it will flip <code>element</code> in the array.</p>
<p>Useful for the large checkbox groups.</p>
<h1 id="data-bound-controls">Data-bound controls</h1>
<h2 id="ad-hoc-data-binding">Ad-hoc data binding</h2>
<h3 id="-link-props-">{ ...link.props }</h3>
<p>Bind the linked value to any standard UI control expecting <code>value</code> and <code>onChange</code> props.</p>
<h3 id="text-input">text input</h3>
<p>Bind input or textarea to the linked string:</p>
<pre><code class="highlight javascript"><span class="hljs-comment">// String</span>
&lt;input type=<span class="hljs-string">"text"</span> {...link.props} /&gt;
<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-title">textarea</span> {<span class="hljs-attribute">...link.props</span>} /&gt;</span></span>
</code></pre>
<h3 id="checkbox">checkbox</h3>
<p>Bind the checkbox to the linked boolean:</p>
<pre><code class="highlight javascript">&lt;input type=<span class="hljs-string">"checkbox"</span> {...boolLink.props } /&gt;
</code></pre>
<p>Bind the checkbox to the presence of value in the array:</p>
<pre><code class="highlight javascript"><span class="hljs-comment">// array = [ 'optionA' ]</span>
&lt;input type=<span class="hljs-string">"checkbox"</span>  {...arrayLink.contains( <span class="hljs-string">'optionA'</span> ).props } /&gt; <span class="hljs-comment">// Checked</span>
&lt;input type=<span class="hljs-string">"checkbox"</span>  {...arrayLink.contains( <span class="hljs-string">'optionB'</span> ).props } /&gt; <span class="hljs-comment">// Unchecked</span>
</code></pre>
<p>Bind the checkbox to the presence of the record in the collection: </p>
<pre><code class="highlight javascript">&lt;input type=<span class="hljs-string">"checkbox"</span> {...collection.linkContains( record ).props } /&gt;
</code></pre>
<h3 id="radio-group">radio group</h3>
<p>Bind radio group to the single linked value:</p>
<pre><code class="highlight javascript"><span class="hljs-comment">// Radio</span>
&lt;input type=<span class="hljs-string">"radio"</span> {...link.equals( <span class="hljs-string">'optionA'</span> ).props } /&gt;
<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-title">input</span> <span class="hljs-attribute">type</span>=<span class="hljs-value">"radio"</span> {<span class="hljs-attribute">...link.equals</span>( '<span class="hljs-attribute">optionB</span>' )<span class="hljs-attribute">.props</span> } /&gt;</span></span>
</code></pre>
<h3 id="select-list">select list</h3>
<p>Bind select list to the linked value:</p>
<pre><code class="highlight javascript"><span class="hljs-comment">// Select</span>
&lt;select {...link.props}&gt;
    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-title">option</span> <span class="hljs-attribute">value</span>=<span class="hljs-value">"optionA"</span>&gt;</span> A <span class="hljs-tag">&lt;/<span class="hljs-title">option</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-title">option</span> <span class="hljs-attribute">value</span>=<span class="hljs-value">"optionB"</span>&gt;</span> B <span class="hljs-tag">&lt;/<span class="hljs-title">option</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-title">select</span>&gt;</span></span>
</code></pre>
<h2 id="linked-ui-controls">Linked UI controls</h2>
<p><em>Linked control</em> is the custom React component taking the <code>link</code> property instead of <code>value</code>/<code>onChange</code> props pair.
It uses the link to extract the value and validation error, and to modify the value.</p>
<p>Linked controls makes it possible to create the semantic form markup encapsulating inline validation
and form layout styling. Not just form controls, but the most of the UI can benefit of this technique.</p>
<pre><code class="highlight javascript"><span class="hljs-comment">// Custom data-bound control</span>
<span class="hljs-keyword">const</span> Input = ({ link, ...props }) =&gt; (
    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-title">div</span> <span class="hljs-attribute">className</span>=<span class="hljs-value">{`form-row</span> ${ <span class="hljs-attribute">link.error</span> ? '<span class="hljs-attribute">has-error</span>' <span class="hljs-attribute">:</span> '' } `}&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-title">input</span> <span class="hljs-attribute">type</span>=<span class="hljs-value">"text"</span> {<span class="hljs-attribute">...props</span>} { <span class="hljs-attribute">...link.props</span> } /&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-title">div</span> <span class="hljs-attribute">className</span>=<span class="hljs-value">"error-placeholder"</span>&gt;</span>{ link.error || '' } <span class="hljs-tag">&lt;/<span class="hljs-title">div</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-title">div</span>&gt;</span>
)</span>;

<span class="hljs-comment">// Another simple data bound control</span>
<span class="hljs-keyword">const</span> Input = ({ link, ...props }) =&gt; (
    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-title">input</span> {<span class="hljs-attribute">...props</span>}
            <span class="hljs-attribute">value</span>=<span class="hljs-value">{</span> <span class="hljs-attribute">link.value</span> }
            <span class="hljs-attribute">onChange</span>=<span class="hljs-value">{</span> <span class="hljs-attribute">e</span> =&gt;</span> link.set( e.target.value ) } /&gt;
)</span>;
</code></pre>
<p>There are the set of pre-defined linked UI controls in <code>react-mvx/tags</code> modules. Inline error indication is rather project-dependent, thus this file is intended to be used as a reference and starting boilerplate for your controls.</p>
<pre><code class="highlight javascript"><span class="hljs-keyword">import</span> { Input } <span class="hljs-keyword">from</span> <span class="hljs-string">'react-mvx/tags'</span>
</code></pre>
<h3 id="text-input">text input</h3>
<p><code>tags.jsx</code> contains wrappers for standard <code>&lt;input&gt;</code> and <code>&lt;textarea&gt;</code> tags,
  which consume linked strings. These wrappers add <code>invalid</code> class to enclosed HTML element if an error is present in the link,
  and <code>required</code> class if <code>isRequired</code> validator is the failing one.</p>
<pre><code class="highlight javascript"><span class="hljs-keyword">import</span> { Input, TextArea } <span class="hljs-keyword">from</span> <span class="hljs-string">'react-mvx/tags'</span>
...
&lt;Input type=<span class="hljs-string">"text"</span> valueLink={ link } /&gt;
&lt;TextArea valueLink={ link } /&gt;
</code></pre>
<p>Its implementation is rather straightforward.</p>
<h3 id="numeric-input">numeric input</h3>
<p>In some cases you can use the <em>wrong input rejection</em> instead of (or in addition to) the validation. The most popular
example is the numeric-only input control. It guarantees that the linked value will only be updated with the valid number,
completely encapsulating all related checks and mechanics.</p>
<p>The challenge here is that when number in not an <em>integer</em> it has to go through the sequence of intermediate invalid states during the editing process.
Like &quot;&quot; -&gt; &quot;-&quot; -&gt; &quot;-0&quot; -&gt; &quot;-0.&quot; -&gt; &quot;-0.5&quot;.</p>
<p>The proper implementation of wrong input rejection might be tough.
<code>tags.jsx</code> contains the cross-browser numeric input tag. It has following differences compared to the regular <code>&lt;Input&gt;</code>:</p>
<ul>
<li>Keyboard input which obviously leads to invalid values (e.g. letters) is rejected.</li>
<li>Link value is guaranteed to be the valid number.</li>
<li>There are <code>integer</code> and <code>positive</code> boolean props controlling input rejection. They can be combined.</li>
</ul>
<p><code>&lt;NumberInput&gt;</code> validates its intermediate state and adds <code>invalid</code> class to enclosed input element if it&#39;s not a number.</p>
<pre><code class="highlight jsx">import { NumberInput } from 'react-mvx/tags'

<span class="hljs-tag">&lt;<span class="hljs-title">NumberInput</span> <span class="hljs-attribute">valueLink</span>=<span class="hljs-value">{</span> <span class="hljs-attribute">link</span> } /&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-title">NumberInput</span> <span class="hljs-attribute">valueLink</span>=<span class="hljs-value">{</span> <span class="hljs-attribute">link</span> } <span class="hljs-attribute">integer</span>=<span class="hljs-value">{</span> <span class="hljs-attribute">true</span> }/&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-title">NumberInput</span> <span class="hljs-attribute">valueLink</span>=<span class="hljs-value">{</span> <span class="hljs-attribute">link</span> } <span class="hljs-attribute">positive</span>=<span class="hljs-value">{</span> <span class="hljs-attribute">true</span> }/&gt;</span>
</code></pre>
<h3 id="checkbox">checkbox</h3>
<p>There are different ways how you can handle the checkbox components. The problem of the standard 
checkbox control, though, is that it&#39;s not that easily styled.</p>
<p><code>tags.jsx</code> contains the custom checkbox and radio components implemented using the plain <code>&lt;div /&gt;</code>
 element which toggles <code>selected</code> class on click. By default, it has <code>checkbox</code> CSS class,
  which can be overridden by passing <code>className</code> prop. It passes through anything else, including <code>children</code>.</p>
<pre><code class="highlight jsx"><span class="hljs-tag">&lt;<span class="hljs-title">Checkbox</span> <span class="hljs-attribute">checkedLink</span>=<span class="hljs-value">{</span> <span class="hljs-attribute">booleanLink</span> } /&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-title">Checkbox</span> <span class="hljs-attribute">checkedLink</span>=<span class="hljs-value">{</span> <span class="hljs-attribute">arrayLink.contains</span>( '<span class="hljs-attribute">option</span>' ) } /&gt;</span>
</code></pre>
<h3 id="radio-group">radio group</h3>
<p>There are two different ways how you can approach the data binding for the radio groups.
First option is to pass the <code>value</code> of the particular option along with the link. Link this:</p>
<pre><code class="highlight jsx"><span class="hljs-tag">&lt;<span class="hljs-title">label</span>&gt;</span>
    A: <span class="hljs-tag">&lt;<span class="hljs-title">Input</span> <span class="hljs-attribute">type</span>=<span class="hljs-value">"radio"</span> <span class="hljs-attribute">valueLink</span>=<span class="hljs-value">{</span> <span class="hljs-attribute">flagLink</span> } <span class="hljs-attribute">value</span>=<span class="hljs-value">"a"</span> /&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-title">label</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-title">label</span>&gt;</span>
    B: <span class="hljs-tag">&lt;<span class="hljs-title">Input</span> <span class="hljs-attribute">type</span>=<span class="hljs-value">"radio"</span> <span class="hljs-attribute">valueLink</span>=<span class="hljs-value">{</span> <span class="hljs-attribute">flagLink</span> } <span class="hljs-attribute">value</span>=<span class="hljs-value">"b"</span> /&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-title">label</span>&gt;</span>
</code></pre>
<p>Alternatively, you can use <code>link.equals( value )</code> method to produce the boolean
link which is specially designed to create radio groups, as it&#39;s illustrated by
the custom <code>&lt;Radio /&gt;</code> tags from the <code>tags.jsx</code>.</p>
<p>Internally, it&#39;s <code>&lt;div&gt;</code> element which always sets its link to <code>true</code> on click.
And whenever the link value is <code>true</code>, it adds <code>selected</code> class to the div.</p>
<p>By default, it has <code>radio</code> CSS class, which can be overridden by passing <code>className</code> prop.
It passes through anything else, including <code>children</code>.</p>
<pre><code class="highlight jsx"><span class="hljs-tag">&lt;<span class="hljs-title">label</span>&gt;</span>
    A: <span class="hljs-tag">&lt;<span class="hljs-title">Radio</span> <span class="hljs-attribute">checkedLink</span>=<span class="hljs-value">{</span> <span class="hljs-attribute">flagLink.equals</span>( '<span class="hljs-attribute">a</span>' ) } /&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-title">label</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-title">label</span>&gt;</span>
    B: <span class="hljs-tag">&lt;<span class="hljs-title">Radio</span> <span class="hljs-attribute">checkedLink</span>=<span class="hljs-value">{</span> <span class="hljs-attribute">flagLink.equals</span>( '<span class="hljs-attribute">b</span>' ) } /&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-title">label</span>&gt;</span>
</code></pre>
        </div>
    </div>
  </body>
</html>
