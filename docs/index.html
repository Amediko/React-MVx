<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta content="IE=edge,chrome=1" http-equiv="X-UA-Compatible">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <title>React-MVx 1.0 API Reference</title>

    <link rel="icon" href="images/logo-dark.png" />
    <link href="lib/stylesheets/screen.css" rel="stylesheet" type="text/css" media="screen" />
    <link href="lib/stylesheets/print.css" rel="stylesheet" type="text/css" media="print" />
    <link href="lib/stylesheets/default.css" rel="stylesheet" type="text/css" />

    <style>
      .logo-section img {
        vertical-align: middle;
        margin: 15px;
        height: 48px;
      }

      .logo-section .logo-text {
        vertical-align: middle;
        color: white;
        display: inline-block;
      }

      .logo-section .logo-caption {
        font-size: 28px;
      }

    </style>
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.0/jquery.min.js"></script>
      <script src="lib/javascripts/all.js" type="text/javascript"></script>

      <script>
        $(function() {
          var langs = [];
          setupLanguages( langs );
        });
      </script>
  </head>

  <body class="index">
    <a href="#" id="nav-button">
      <span>
        NAV
        <img src="images/navbar.png" />
      </span>
    </a>
    <div class="tocify-wrapper">
      <div class="logo-section">
        <img src="images/logo.png" />
        <div class="logo-text">
          <div class="logo-caption">Type-R 1.0</div>
          <div>universal state management</div>
        </div>
        
      </div>
        <div class="lang-selector">
        </div>
        <div class="search">
          <input type="text" class="search" id="input-search" placeholder="Search">
        </div>
        <ul class="search-results"></ul>
      <div id="toc">
      </div>
        <ul class="toc-footer">
                <li><a href="https://github.com/Volicon/React-MVx">GitHub repository</a></li>
                <li><a href="https://github.com/Volicon/React-MVx/issues">Ask the question or report the bug</a></li>
                <li><a href="http://www.volicon.com/">Supported by <img style="vertical-align: middle" src="images/volicon_verizon_dm.png"/></a></li>
        </ul>
    </div>
    <div class="page-wrapper">
        <div class="content">
          <h1 id="getting-started">Getting started</h1>
<p>React-MVx is the MVVM SPA framework with React as View layer, which is built upon frontend technologies used at Volicon/Verizon for 3 years.</p>
<p>Contrary to the popular React approaches, React-MVx does not try to avoid the distributed mutable application state. Instead, it is focused on bringing stateful components capabilities to their maximum.</p>
<p>React-MVx manages both local UI state and application domain state with the same universal state container provided by <a href="https://volicon.github.com/Type-R">Type-R</a> data framework. It supports:</p>
<ul>
<li>two-way data binding</li>
<li>declarative state validation</li>
<li>nested data structures &amp; observable changes</li>
<li>painless state synchronization</li>
<li>automatic JSON serialization</li>
</ul>
<p>React-MVx application architecture follows scalable MVVM architecture pattern. It features the <em>unidirectional data flow</em> and <em>pure render</em> optimization. But contrary to the popular React state management solutions:</p>
<ul>
<li>It doesn&#39;t rely on singletons (unless you <em>really</em> need some data to be shared across pages)</li>
<li>It assists and encourages usage of <em>locally encapsulated state</em> and <em>OO decomposition</em>.</li>
</ul>
<h2 id="overview">Overview</h2>
<p>React-MVx is built around the idea of <em>universal state management</em> featuring 
the same technique to manage the local component state, application page state,
and the global application state.</p>
<p>Basic building blocks of the application architecture are:</p>
<ul>
<li>React-MVx Component (extended React.Component) for the view layer.</li>
<li>Records and Collection (provided by Type-R data framework) for managing all kinds of an application state.</li>
<li>Links for two-way data binding.</li>
<li>Stores (which is the subclass of the Record and can be dynamically created) for resolving record&#39;s id-references.</li>
</ul>
<p>React-MVx Component uses the Record class to manage its local state. Record can consists of other records 
and collections, describing the data structure of arbitrary complexity. All records are serializable by default, has deeply observable changes, and supports the declarative validation.</p>
<p>The behavior of record&#39;s attributes and component state/props elements is controlled with declarative <em>type annotations</em>. </p>
<p>React-MVx extends React namespace and should be used instead of <code>react</code>.
All class Component definitions must be preceeded with the <code>@define</code> decorator.</p>
<pre><code class="highlight javascript"><span class="hljs-keyword">import</span> React, { define } <span class="hljs-keyword">from</span> <span class="hljs-string">'react-mvx'</span>

@define <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloApp</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>{
    <span class="hljs-keyword">static</span> state = {
        <span class="hljs-attr">count</span> : <span class="hljs-number">0</span>
    };

    render(){
        <span class="hljs-keyword">const</span> { state } = <span class="hljs-keyword">this</span>;
        <span class="hljs-keyword">return</span> (
            <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{</span> () =&gt;</span> state.count++ }&gt;
                Hi there! { state.count }
            <span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span>;
        );
    }
}
</code></pre>
<h2 id="installation-requirements">Installation &amp; Requirements</h2>
<p>Supported browsers: Chrome, Firefox, Safari, IE10+.</p>
<p>Requires <code>react</code> and <code>type-r</code> as peer dependencies. Installation (assuming that React is installed):</p>
<pre><code><span class="hljs-string">`npm install react-mvx type-r --save-dev`</span>


</code></pre><p>TypeScript is unsupported (yet) but may work.</p>
<p>MIT License. Used and supported by Volicon and Verizon Digital Media Services.</p>

<h1 id="tutorials">Tutorials</h1>
<h2 id="data-binding-and-forms">Data binding and forms</h2>
<h2 id="input-validation">Input validation</h2>
<h2 id="editable-lists">Editable lists</h2>
<h2 id="paging">Paging</h2>
<p>TBD</p>
<h2 id="relations-and-stores">Relations and stores</h2>
<p>TBD</p>
<h2 id="layered-application-state">Layered application state</h2>
<p>TBD</p>
<h1 id="component">Component</h1>
<p>React-MVx extends React namespace and should be used instead of <code>react</code>.
All class Component definitions must be preceeded with the <code>@define</code> decorator.</p>
<p>All features of the Component are controlled through the unified property and attribute declarations.</p>
<pre><code class="highlight javascript"><span class="hljs-keyword">import</span> React, { define } <span class="hljs-keyword">from</span> <span class="hljs-string">'react-mvx'</span>

@define <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Hello</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>{
    <span class="hljs-keyword">static</span> props = { <span class="hljs-comment">// instead of `propTypes` and `defaultProps`</span>
        propName : <span class="hljs-string">`propDef`</span>,
        ...
    }

    <span class="hljs-keyword">static</span> context = { <span class="hljs-comment">// instead of `contextTypes`</span>
        propName : <span class="hljs-string">`propDef`</span>,
        ...
    }

    <span class="hljs-keyword">static</span> childContext = { <span class="hljs-comment">// instead of `childContextTypes`</span>
        propName : <span class="hljs-string">`propDef`</span>,
        ...
    }

    <span class="hljs-keyword">static</span> state = { <span class="hljs-comment">// instead of "this.state = " in the constructor.</span>
        attrName : <span class="hljs-string">`attrDef`</span>,
        ...
    }

    <span class="hljs-keyword">static</span> store = { <span class="hljs-comment">// store</span>
        attrName : <span class="hljs-string">`attrDef`</span>,
        ...
    }

    render(){...}
}
</code></pre>
<h2 id="props-and-state-definitions">props and state definitions</h2>
<p>The majority of React-MVx features are controlled with declarative props, state, store, and context type annotations.</p>
<h3 id="everything-state-store-props-and-context-">Everything (state, store, props, and context)</h3>
<p>Type annotations below represents the run-time type assertions.</p>
<table>
<thead>
<tr>
<th>Annotation</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td><code>Ctor</code></td>
<td>element has specified type</td>
</tr>
<tr>
<td></td>
<td><code>Ctor.isRequired</code></td>
<td>element is required</td>
</tr>
<tr>
<td></td>
<td><code>Ctor.has.check(...)</code></td>
<td>custom validation check</td>
</tr>
</tbody>
</table>
<h3 id="state-store-and-props">state, store, and props</h3>
<p>You can specify the default value for an attribute or prop, and reactions on its change.</p>
<table>
<thead>
<tr>
<th>Annotation</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td><code>Ctor.value( defaultValue )</code></td>
<td>element has default value</td>
</tr>
<tr>
<td></td>
<td><code>defaultValue</code></td>
<td>element has default value</td>
</tr>
<tr>
<td></td>
<td><code>Ctor.has.watcher(...)</code></td>
<td>custom reaction on element&#39;s change </td>
</tr>
<tr>
<td></td>
<td><code>Ctor.has.events(...)</code></td>
<td>listen to custom events from the element</td>
</tr>
<tr>
<td></td>
<td><code>Ctor.has.changeEvents(...)</code></td>
<td>update on element&#39;s changes</td>
</tr>
</tbody>
</table>
<h3 id="state-and-store">state and store</h3>
<p>You have an an attribute-level control of the serialization and ownership for the state, store, and records attributes.</p>
<table>
<thead>
<tr>
<th>Annotation</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td><code>Record.shared</code></td>
<td>attribute holds the reference to the record</td>
<td></td>
</tr>
<tr>
<td></td>
<td><code>Collection.Refs</code></td>
<td>collection of references to the records</td>
<td></td>
</tr>
<tr>
<td></td>
<td><code>Record.from(...)</code></td>
<td>reference to the record from the specified collection</td>
<td></td>
</tr>
<tr>
<td></td>
<td><code>Collection.subsetOf(...)</code></td>
<td>collection of references to the records from the specified collection</td>
<td></td>
</tr>
<tr>
<td></td>
<td><code>Ctor.has.parse(...)</code></td>
<td>custom parse hook</td>
<td></td>
</tr>
<tr>
<td></td>
<td><code>Ctor.has.toJSON(...)</code></td>
<td>custom serialization hook</td>
<td></td>
</tr>
<tr>
<td></td>
<td><code>Ctor.has.get(...)</code></td>
<td>attribute read hook</td>
<td></td>
</tr>
<tr>
<td></td>
<td><code>Ctor.has.set(...)</code></td>
<td>attribute write hook</td>
<td></td>
</tr>
<tr>
<td></td>
<td><code>Ctor.has.metadata(...)</code></td>
<td>attach custom metadata to the attribute</td>
<td></td>
</tr>
</tbody>
</table>
<h1 id="link">Link</h1>
<p>Link is an intermediate object used to implement the two-way data binding.
It acts like a transport for the value, the callback to modify it, its validation error, abstracting out
UI controls from the data representation in the state container and from the state container per se.</p>
<p>Links to the record&#39;s attributes are commonly created with <code>linkAt</code> and <code>linkAll</code> methods of records.
Record is automatically validated upon the links creation, and link encloses the validation error
related to the particuler attribute.</p>
<pre><code class="highlight javascript"><span class="hljs-comment">// Data bound control for the semantic form markup</span>
<span class="hljs-keyword">const</span> Input = <span class="hljs-function">(<span class="hljs-params">{ valueLink, ...props }</span>) =&gt;</span> (
    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">{</span>`<span class="hljs-attr">form-control</span> ${ <span class="hljs-attr">valueLink.error</span> ? '<span class="hljs-attr">error</span>' <span class="hljs-attr">:</span> '' }`}&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">input</span> {<span class="hljs-attr">...props</span>}
            <span class="hljs-attr">value</span>=<span class="hljs-string">{</span> <span class="hljs-attr">valueLink.value</span> }
            <span class="hljs-attr">onChange</span>=<span class="hljs-string">{</span> <span class="hljs-attr">e</span> =&gt;</span> valueLink.set( e.target.value ) }
        /&gt;
        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">"validation-error"</span>&gt;</span>{ valueLink.error || '' }<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
);</span>
</code></pre>
<p>Links makes it possible to create the semantic markup for the form elements, encapsulating the
all the required styles and validation error indication.</p>
<h1 id="data-bound-controls">Data-bound controls</h1>
<h2 id="ad-hoc-data-binding">Ad-hoc data binding</h2>
<h3 id="-link-props-">{ ...link.props }</h3>
<p>Bind the linked value to any standard UI control expecting <code>value</code> and <code>onChange</code> props.</p>
<h3 id="text-input">text input</h3>
<p>Bind input or textarea to the linked string:</p>
<pre><code class="highlight javascript"><span class="hljs-comment">// String</span>
&lt;input type=<span class="hljs-string">"text"</span> {...link.props} /&gt;
<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">textarea</span> {<span class="hljs-attr">...link.props</span>} /&gt;</span></span>
</code></pre>
<h3 id="checkbox">checkbox</h3>
<p>Bind the checkbox to the linked boolean:</p>
<pre><code class="highlight javascript">&lt;input type=<span class="hljs-string">"checkbox"</span> {...boolLink.props } /&gt;
</code></pre>
<p>Bind the checkbox to the presence of value in the array:</p>
<pre><code class="highlight javascript"><span class="hljs-comment">// array = [ 'optionA' ]</span>
&lt;input type=<span class="hljs-string">"checkbox"</span>  {...arrayLink.contains( <span class="hljs-string">'optionA'</span> ).props } /&gt; <span class="hljs-comment">// Checked</span>
&lt;input type=<span class="hljs-string">"checkbox"</span>  {...arrayLink.contains( <span class="hljs-string">'optionB'</span> ).props } /&gt; <span class="hljs-comment">// Unchecked</span>
</code></pre>
<p>Bind the checkbox to the presence of the record in the collection: </p>
<pre><code class="highlight javascript">&lt;input type=<span class="hljs-string">"checkbox"</span> {...collection.linkContains( record ).props } /&gt;
</code></pre>
<h3 id="radio-group">radio group</h3>
<p>Bind radio group to the single linked value:</p>
<pre><code class="highlight javascript"><span class="hljs-comment">// Radio</span>
&lt;input type=<span class="hljs-string">"radio"</span> {...link.equals( <span class="hljs-string">'optionA'</span> ).props } /&gt;
<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"radio"</span> {<span class="hljs-attr">...link.equals</span>( '<span class="hljs-attr">optionB</span>' )<span class="hljs-attr">.props</span> } /&gt;</span></span>
</code></pre>
<h3 id="select-list">select list</h3>
<p>Bind select list to the linked value:</p>
<pre><code class="highlight javascript">// Select
&lt;select {...link.props}&gt;
    &lt;option value="optionA"&gt; A &lt;/option&gt;
    &lt;option value="optionB"&gt; B &lt;/option&gt;
&lt;/select&gt;
</code></pre>
<h2 id="linked-ui-controls">Linked UI controls</h2>
<p><em>Linked control</em> is the custom React component taking the <code>link</code> property instead of <code>value</code>/<code>onChange</code> props pair.
It uses the link to extract the value and validation error, and to modify the value.</p>
<p>Linked controls makes it possible to create the semantic form markup encapsulating inline validation
and form layout styling. Not just form controls, but the most of the UI can benefit of this technique.</p>
<pre><code class="highlight javascript"><span class="hljs-comment">// Custom data-bound control</span>
<span class="hljs-keyword">const</span> Input = <span class="hljs-function">(<span class="hljs-params">{ link, ...props }</span>) =&gt;</span> (
    &lt;div className={`form-row ${ link.error ? 'has-error' : '' } `}&gt;
        &lt;input type="text" {...props} { ...link.props } /&gt;
        &lt;div className="error-placeholder"&gt;{ link.error || '' } &lt;/div&gt;
    &lt;/div&gt;
);

// Another simple data bound control
const Input = ({ link, ...props }) =&gt; (
    &lt;input {...props}
            value={ link.value }
            onChange={ e =&gt; link.set( e.target.value ) } /&gt;
);
</code></pre>
<p>There are the set of pre-defined linked UI controls in <code>react-mvx/tags</code> modules. Inline error indication is rather project-dependent, thus this file is intended to be used as a reference and starting boilerplate for your controls.</p>
<pre><code class="highlight javascript"><span class="hljs-keyword">import</span> { Input } <span class="hljs-keyword">from</span> <span class="hljs-string">'react-mvx/tags'</span>
</code></pre>
<h3 id="text-input">text input</h3>
<p><code>tags.jsx</code> contains wrappers for standard <code>&lt;input&gt;</code> and <code>&lt;textarea&gt;</code> tags,
  which consume linked strings. These wrappers add <code>invalid</code> class to enclosed HTML element if an error is present in the link,
  and <code>required</code> class if <code>isRequired</code> validator is the failing one.</p>
<pre><code class="highlight javascript"><span class="hljs-keyword">import</span> { Input, TextArea } <span class="hljs-keyword">from</span> <span class="hljs-string">'react-mvx/tags'</span>
...
&lt;Input type=<span class="hljs-string">"text"</span> valueLink={ link } /&gt;
<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">TextArea</span> <span class="hljs-attr">valueLink</span>=<span class="hljs-string">{</span> <span class="hljs-attr">link</span> } /&gt;</span></span>
</code></pre>
<p>Its implementation is rather straightforward.</p>
<h3 id="numeric-input">numeric input</h3>
<p>In some cases you can use the <em>wrong input rejection</em> instead of (or in addition to) the validation. The most popular
example is the numeric-only input control. It guarantees that the linked value will only be updated with the valid number,
completely encapsulating all related checks and mechanics.</p>
<p>The challenge here is that when number in not an <em>integer</em> it has to go through the sequence of intermediate invalid states during the editing process.
Like &quot;&quot; -&gt; &quot;-&quot; -&gt; &quot;-0&quot; -&gt; &quot;-0.&quot; -&gt; &quot;-0.5&quot;.</p>
<p>The proper implementation of wrong input rejection might be tough.
<code>tags.jsx</code> contains the cross-browser numeric input tag. It has following differences compared to the regular <code>&lt;Input&gt;</code>:</p>
<ul>
<li>Keyboard input which obviously leads to invalid values (e.g. letters) is rejected.</li>
<li>Link value is guaranteed to be the valid number.</li>
<li>There are <code>integer</code> and <code>positive</code> boolean props controlling input rejection. They can be combined.</li>
</ul>
<p><code>&lt;NumberInput&gt;</code> validates its intermediate state and adds <code>invalid</code> class to enclosed input element if it&#39;s not a number.</p>
<pre><code class="highlight jsx"><span class="hljs-keyword">import</span> { NumberInput } <span class="hljs-keyword">from</span> <span class="hljs-string">'react-mvx/tags'</span>

&lt;NumberInput valueLink={ link } /&gt;
&lt;NumberInput valueLink={ link } integer={ true }/&gt;
&lt;NumberInput valueLink={ link } positive={ true }/&gt;
</code></pre>
<h3 id="checkbox">checkbox</h3>
<p>There are different ways how you can handle the checkbox components. The problem of the standard 
checkbox control, though, is that it&#39;s not that easily styled.</p>
<p><code>tags.jsx</code> contains the custom checkbox and radio components implemented using the plain <code>&lt;div /&gt;</code>
 element which toggles <code>selected</code> class on click. By default, it has <code>checkbox</code> CSS class,
  which can be overridden by passing <code>className</code> prop. It passes through anything else, including <code>children</code>.</p>
<pre><code class="highlight jsx">&lt;Checkbox checkedLink={ booleanLink } /&gt;
<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">Checkbox</span> <span class="hljs-attr">checkedLink</span>=<span class="hljs-string">{</span> <span class="hljs-attr">arrayLink.contains</span>( '<span class="hljs-attr">option</span>' ) } /&gt;</span></span>
</code></pre>
<h3 id="radio-group">radio group</h3>
<p>There are two different ways how you can approach the data binding for the radio groups.
First option is to pass the <code>value</code> of the particular option along with the link. Link this:</p>
<pre><code class="highlight jsx">&lt;label&gt;
    A: <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">Input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"radio"</span> <span class="hljs-attr">valueLink</span>=<span class="hljs-string">{</span> <span class="hljs-attr">flagLink</span> } <span class="hljs-attr">value</span>=<span class="hljs-string">"a"</span> /&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span></span>
&lt;label&gt;
    B: <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">Input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"radio"</span> <span class="hljs-attr">valueLink</span>=<span class="hljs-string">{</span> <span class="hljs-attr">flagLink</span> } <span class="hljs-attr">value</span>=<span class="hljs-string">"b"</span> /&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span></span>
</code></pre>
<p>Alternatively, you can use <code>link.equals( value )</code> method to produce the boolean
link which is specially designed to create radio groups, as it&#39;s illustrated by
the custom <code>&lt;Radio /&gt;</code> tags from the <code>tags.jsx</code>.</p>
<p>Internally, it&#39;s <code>&lt;div&gt;</code> element which always sets its link to <code>true</code> on click.
And whenever the link value is <code>true</code>, it adds <code>selected</code> class to the div.</p>
<p>By default, it has <code>radio</code> CSS class, which can be overridden by passing <code>className</code> prop.
It passes through anything else, including <code>children</code>.</p>
<pre><code class="highlight jsx">&lt;label&gt;
    A: <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">Radio</span> <span class="hljs-attr">checkedLink</span>=<span class="hljs-string">{</span> <span class="hljs-attr">flagLink.equals</span>( '<span class="hljs-attr">a</span>' ) } /&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span></span>
&lt;label&gt;
    B: <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">Radio</span> <span class="hljs-attr">checkedLink</span>=<span class="hljs-string">{</span> <span class="hljs-attr">flagLink.equals</span>( '<span class="hljs-attr">b</span>' ) } /&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span></span>
</code></pre>
        </div>
    </div>
  </body>
</html>
